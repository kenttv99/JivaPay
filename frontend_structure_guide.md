# Рекомендации по структуре Next.js приложений

Это руководство описывает рекомендуемую структуру для управления API-запросами и стилями в отдельных Next.js приложениях (например, `trader_app`, `merchant_app`), предполагая использование `src/` директории и App Router.

## 1. Управление запросами (API, состояние)

### Клиент для API

*   **Где:** Создайте директорию `src/lib/api` или `src/services/api`.
*   **Что:** Функции для взаимодействия с вашим бэкендом или сторонними API. Используйте `fetch` или библиотеку вроде `axios`.
*   **Пример:**
    ```typescript
    // src/lib/api/auth.ts
    import axios from 'axios'; // или ваш настроенный инстанс

    const apiClient = axios.create({ baseURL: '/api' }); // Пример с Next.js API routes или вашим бэкендом

    export const loginUser = async (credentials) => {
      const response = await apiClient.post('/auth/login', credentials);
      return response.data;
    };

    // src/lib/api/products.ts
    export const getProducts = async () => { /* ... */ };
    ```

### Управление состоянием данных с сервера (Client-Side)

*   **Рекомендация:** Используйте `React Query (TanStack Query)` или `SWR` для упрощения получения, кэширования и синхронизации серверных данных.
*   **Где:** Хуки можно вызывать в компонентах или создать кастомные хуки в `src/hooks/api` или `src/lib/api/hooks.ts`.
*   **Пример (с React Query):**
    ```typescript
    // src/hooks/api/useProducts.ts
    import { useQuery } from '@tanstack/react-query';
    import { getProducts } from '@/lib/api/products'; // Используем alias @/, если настроили

    export const useProducts = () => {
      return useQuery({ queryKey: ['products'], queryFn: getProducts });
    };

    // В компоненте:
    // import { useProducts } from '@/hooks/api/useProducts';
    // const { data: products, isLoading, error } = useProducts();
    ```

### Next.js App Router (Server Components & Server Actions)

*   **Получение данных:** В Server Components (`*.tsx` файлы в `src/app/` без `"use client"`) можно получать данные напрямую, используя `fetch` или ваш API-клиент.
*   **Мутации данных (Создание/Обновление/Удаление):** Используйте Server Actions. Определяйте их в файлах с директивой `"use server"` (в `src/actions/` или прямо в компонентах) и вызывайте из Client Components (`"use client"`).

## 2. Управление стилями

### Глобальные стили

*   **Где:** `src/app/globals.css` (или `src/styles/globals.css`).
*   **Что:** Стили для всего приложения (сброс, базовые стили `body`, CSS переменные). Импортируйте в корневой `layout.tsx`.
*   **Пример (`src/app/layout.tsx`):**
    ```typescript
    import type { Metadata } from "next";
    import { Inter } from "next/font/google";
    import "@/app/globals.css"; // Импорт глобальных стилей

    const inter = Inter({ subsets: ["latin"] });

    export const metadata: Metadata = {
      title: "Create Next App",
      description: "Generated by create next app",
    };

    export default function RootLayout({
      children,
    }: Readonly<{
      children: React.ReactNode;
    }>) {
      return (
        <html lang="en">
          <body className={inter.className}>{children}</body>
        </html>
      );
    }
    ```

### Локальные стили (CSS Modules)

*   **Рекомендация:** Основной способ стилизации компонентов.
*   **Где:** Файлы `[ComponentName].module.css` рядом с компонентами (например, `src/components/Button/Button.module.css`).
*   **Что:** Локализованные стили. Импортируйте объект стилей в компонент.
*   **Пример:**
    ```css
    /* src/components/Button/Button.module.css */
    .button {
      background-color: blue;
      color: white;
      padding: 10px 15px;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out; /* Пример */
    }
    .button:hover {
      background-color: darkblue;
    }
    ```
    ```typescript
    // src/components/Button/Button.tsx
    import styles from './Button.module.css';

    interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
        children: React.ReactNode;
    }

    export function Button({ children, ...props }: ButtonProps) {
      return <button className={styles.button} {...props}>{children}</button>;
    }
    ```

### Tailwind CSS

*   Если используется, классы применяются прямо в JSX.
*   Конфигурация: `tailwind.config.ts`.
*   Глобальные стили: `globals.css` с директивами `@tailwind`.

### CSS-in-JS (Styled Components, Emotion)

*   Возможно использование, но требует дополнительной настройки для App Router. CSS Modules или Tailwind обычно проще.

### Организация компонентов и стилей

*   `src/components/`: Общие, переиспользуемые компоненты.
*   `src/app/.../components/`: Компоненты, специфичные для конкретного маршрута или раздела.
*   Держите файлы `.module.css` рядом с соответствующими файлами `.tsx`.

### Общие стили/переменные

*   Используйте CSS Custom Properties (переменные) в `globals.css`.
    ```css
    /* src/app/globals.css */
    :root {
      --primary-color: #0070f3;
      --secondary-color: #1a1a1a;
      --text-color: #333;
      --background-color: #fff;
      --default-padding: 1rem;
      --border-radius: 8px;
    }

    body {
      padding: var(--default-padding);
      background-color: var(--background-color);
      color: var(--text-color);
    }

    /* Можно определить темную тему */
    @media (prefers-color-scheme: dark) {
      :root {
        --primary-color: #3b82f6; /* Пример другого оттенка */
        --secondary-color: #e5e5e5;
        --text-color: #f0f0f0;
        --background-color: #1a1a1a;
      }
    }
    ```

## 3. Управление состоянием для современного UX (Скелетоны, Загрузка, Ошибки)

Правильное управление состояниями загрузки, ошибок и данных — ключ к современному UX.

### 3.1. Состояние серверных данных (Data Fetching)

*   **Инструменты:** `React Query (TanStack Query)` или `SWR`.
*   **Преимущества для UX:**
    *   **Встроенные состояния:** Предоставляют `isLoading`, `isFetching`, `isError`, `data`, `error`.
    *   **Кэширование:** Ускоряет повторные загрузки, улучшает воспринимаемую производительность.
    *   **Автоматизация:** Повторные запросы, обновление при фокусе и т.д.

### 3.2. Интеграция скелетонов (Skeletons)

*   **Логика:** Показывайте скелетоны, когда `isLoading` равно `true` (из React Query/SWR).
*   **Где:** Условный рендеринг в JSX компонента.
*   **Компоненты скелетонов:** Создайте переиспользуемые компоненты-плейсхолдеры (`src/components/Skeletons/`).
*   **Пример (с React Query):
    ```typescript jsx
    // src/app/profile/page.tsx (или клиентский компонент)
    "use client";

    import { useQuery } from '@tanstack/react-query';
    import { getUserProfile } from '@/lib/api/user';
    import UserProfileCard from '@/components/UserProfileCard';
    import UserProfileSkeleton from '@/components/Skeletons/UserProfileSkeleton';
    import ErrorDisplay from '@/components/ErrorDisplay';

    export default function ProfilePage() {
      const { data: user, isLoading, isError, error } = useQuery({
        queryKey: ['userProfile'],
        queryFn: getUserProfile
      });

      if (isLoading) {
        return <UserProfileSkeleton />; // Показываем скелетон
      }

      if (isError) {
        return <ErrorDisplay message={error?.message || 'Failed to load profile.'} />;
      }

      if (!user) {
         return <div>No profile data found.</div>; // Пустое состояние
      }

      return <UserProfileCard user={user} />;
    }
    ```

### 3.3. Next.js App Router для загрузки

*   **`loading.tsx`:** Создайте этот файл рядом с `page.tsx` для автоматического показа скелетона на уровне маршрута во время серверного рендеринга и получения данных Server Components. Next.js использует его как `fallback` для `React.Suspense`.
    ```typescript jsx
    // src/app/dashboard/loading.tsx
    import DashboardSkeleton from '@/components/Skeletons/DashboardSkeleton';

    export default function Loading() {
      return <DashboardSkeleton />;
    }
    ```
*   **`React.Suspense`:** Используйте для гранулярного контроля загрузки *внутри* страницы, оборачивая асинхронные Server Components.
    ```typescript jsx
    // src/app/some-page/page.tsx
    import { Suspense } from 'react';
    import MyAsyncComponent from '@/components/MyAsyncComponent';
    import MySkeleton from '@/components/Skeletons/MySkeleton';

    export default function SomePage() {
      return (
        <div>
          <h1>My Page</h1>
          <Suspense fallback={<MySkeleton />}>
             <MyAsyncComponent />
          </Suspense>
          {/* Другие компоненты */}
        </div>
      );
    }
    ```

### 3.4. Состояние мутаций (POST/PUT/DELETE)

*   **Server Actions:** Используйте хук `useFormStatus` из `react-dom` в клиентских компонентах для отслеживания `pending` состояния формы и блокировки/индикации во время выполнения.
*   **React Query/SWR:** Используйте `useMutation` для управления состоянием мутаций (`isPending`, `isError` и т.д.).

### 3.5. Обработка ошибок и пустых состояний

*   **Ошибки:** Используйте `isError` / `error` из React Query/SWR и файл `error.tsx` в Next.js для обработки ошибок рендеринга на уровне маршрута.
*   **Пустые состояния:** После загрузки (`isLoading: false`) и без ошибок (`isError: false`), проверьте наличие данных (`data`). Если их нет, отобразите компонент "Empty State".

## 4. Общие рекомендации

*   **Консистентность:** Придерживайтесь выбранных подходов во всем приложении.
*   **Структура `src`:** Используйте логические подпапки (`components`, `lib`, `hooks`, `styles`, `utils`, `app`, `actions`).
*   **Масштабирование:** Эта структура позволяет легко добавлять новые разделы и функциональность. При необходимости разбивайте большие модули на более мелкие.

**Примечание:** Эта структура применяется *внутри каждого* отдельного Next.js приложения (`frontend/trader_app`, `frontend/merchant_app`, и т.д.). 