# План Архитектуры и Базовой Структуры Frontend (TypeScript - Мульти-приложение) - Детализированный

---

## 1. Введение

Этот документ описывает **детализированный** план создания базовой структуры фронтенд-приложений на **TypeScript** для различных ролей пользователей (Мерчант, Трейдер, Админ, Саппорт) системы JivaPay. План основан на бэкенд-архитектуре и документации (`backend/*`), а также учитывает существующую **мульти-аппликационную структуру** директории `frontend/`.

**Цель:** Заложить надежный, масштабируемый и удобный в поддержке фундамент для разработки пользовательских интерфейсов каждой роли, обеспечив при этом консистентность и эффективное переиспользование кода.

**Ключевые Принципы:**

*   **Раздельные SPA:** Каждая роль получает свое независимое приложение. Это упрощает разработку и развертывание специфичного для роли функционала, предотвращает разрастание единой кодовой базы и позволяет независимо масштабировать команды или технологии для разных приложений при необходимости.
*   **TypeScript:** Строгая типизация повышает надежность кода, облегчает рефакторинг, улучшает автодополнение в IDE и помогает ловить ошибки на этапе компиляции, что критически важно для финансовых приложений.
*   **Компонентный подход:** Разбиение интерфейса на переиспользуемые компоненты (кнопки, таблицы, формы, специфичные виджеты) ускоряет разработку, упрощает тестирование и обеспечивает единообразие UI.
*   **Генерация Типов из OpenAPI:** Использование генераторов (например, `openapi-typescript-codegen`) для создания TypeScript-типов на основе OpenAPI спецификации бэкенда **настоятельно рекомендуется**. Это гарантирует синхронизацию моделей данных между фронтендом и бэкендом, минимизируя ошибки интеграции.
*   **Эффективная работа с данными:** Применение серверной пагинации, сортировки и фильтрации для больших списков (ордера, пользователи) предотвращает передачу и обработку избыточных данных на клиенте. Использование библиотек управления серверным состоянием (React Query, RTK Query) оптимизирует кэширование и обновление данных.
*   **Обновления в реальном времени (SSE):** Server-Sent Events используются для немедленного отображения критически важных изменений (статусы ордеров, новые назначения) без необходимости пользователю обновлять страницу или постоянного поллинга, улучшая UX и снижая нагрузку.
*   **Продуманная Обработка Ошибок:** Четкое разделение и обработка ошибок API (сетевые, серверные 5xx, клиентские 4xx) и внутренних ошибок фронтенда (ошибки рендеринга, состояния). Интеграция с системами мониторинга (Sentry) для быстрого обнаружения и исправления проблем.
*   **Консистентность UI/UX:** Достигается за счет использования общих UI-компонентов, единой дизайн-системы (темы) и гайдлайнов, особенно при использовании стратегии с общими пакетами.
*   **Оптимизация загрузки (Lazy Loading):** Маршруты и тяжелые компоненты подгружаются по мере необходимости, улучшая время первоначальной загрузки приложения (TТI).
*   **Доступность (a11y):** При разработке компонентов и страниц учитываются стандарты WCAG для обеспечения возможности использования приложений людьми с ограниченными возможностями.
*   **Интернационализация (i18n):** Архитектура должна быть готова к поддержке нескольких языков, даже если это не требуется на первом этапе. Использование библиотек типа `i18next` и вынесение строк в файлы переводов.
*   **Безопасность:** Надлежащее управление токенами аутентификации (хранение, передача), избегание хранения чувствительной информации в `localStorage`, маскирование данных (API-ключи, номера реквизитов), защита от XSS (в основном обеспечивается фреймворком, но требует внимания при использовании `dangerouslySetInnerHTML`).
*   **Защита от DDoS:** Внедрение многоуровневой защиты от распределенных атак типа "отказ в обслуживании" (DDoS) **на уровне инфраструктуры**. Это включает использование специализированных сервисов (например, CDN с функцией защиты, WAF - Web Application Firewall, облачные сервисы типа AWS Shield/Azure DDoS Protection/Google Cloud Armor) для фильтрации и блокировки вредоносного трафика еще до того, как он достигнет серверов приложений. Эта защита нацелена на все внешние запросы к публичным доменам приложений (`merchant.jivapay.com`, `trader.jivapay.com` и т.д.). В качестве дополнения, на стороне бэкенда должны быть реализованы механизмы ограничения частоты запросов (Rate Limiting) к API для предотвращения злоупотреблений и application-level атак.

---

## 2. Базовая Структура Директорий

*Мульти-аппликационная структура (`merchant_app`, `trader_app` и т.д.) сохраняется. Внутри каждого приложения `src/` будет содержать стандартные поддиректории:* 
    *   `components`: Переиспользуемые React-компоненты.
    *   `pages`: Компоненты верхнего уровня, соответствующие маршрутам приложения.
    *   `layouts`: Компоненты-обертки для страниц (например, с сайдбаром и хедером).
    *   `services`: Модули для взаимодействия с внешним миром (API, SSE).
    *   `hooks`: Кастомные React-хуки для инкапсуляции логики.
    *   `store`: Глобальное состояние приложения (если используется).
    *   `contexts`: React Contexts для проброса данных.
    *   `types`: Определения TypeScript типов/интерфейсов (или импорт из общего пакета).
    *   `utils`: Вспомогательные функции.
    *   `assets`: Статические файлы.
    *   `styles`: Глобальные стили, темы.
*При использовании монорепозитория рекомендуется настройка единых правил форматирования/линтеров (ESLint, Prettier) и общей базовой конфигурации TypeScript (`tsconfig.base.json`) для всех приложений и пакетов.* 

--- 

## 3. Детализированный План Реализации по Ролям (внутри каждого приложения)

Общие шаги для **каждого** приложения:

*   **Настройка проекта:** Инициализация с помощью Vite или CRA, установка зависимостей, настройка TypeScript.
*   **Маршрутизация:** Настройка React Router для навигации внутри приложения.
*   **Аутентификация:** Реализация страницы логина, API запроса для получения токена, безопасного хранения токена (например, в памяти с обновлением через refresh-токены или в `HttpOnly` cookie, если позволяет бэкенд) и механизма защиты маршрутов.
*   **Layout:** Создание основного `AuthenticatedLayout` с навигацией (сайдбар/меню) и хедером.
*   **Управление состоянием:**
    *   **Серверное:** Настройка React Query/RTK Query. Определение базовых запросов и мутаций с использованием типизированных функций из `services/*.ts`.
    *   **UI:** Выбор подхода (Context/Zustand/...) и реализация для необходимого UI-состояния (например, состояние фильтров, открытых модалок).
*   **API Клиент:** Настройка `axios` или `fetch` с интерцепторами для добавления токена авторизации и централизованной обработки ошибок API.
*   **Типизация:** Настройка генерации типов из OpenAPI или создание/импорт базовых типов.
*   **SSE:** Реализация сервиса или хука для установки и управления SSE-соединением, обработки сообщений.
*   **Обработка ошибок:** Настройка Sentry SDK (или аналога) и глобального обработчика ошибок React (Error Boundary).

*(Далее идет детализация для каждой роли, как в предыдущей версии, но с пониманием, что она реализуется в контексте своего приложения и использует описанные выше общие подходы)*

### 3.1. Приложение Мерчанта (`frontend/merchant_app/`)
*   **Ключевая задача:** Предоставить удобный интерфейс для управления магазинами, отслеживания финансовых потоков (балансы, ордера) и получения необходимой информации для интеграции (API ключи, документация).
*   **Детализация страниц:**
    *   `pages/Dashboard.tsx`: Отображение текущих балансов (`BalanceStore[]`), статусов магазинов, виджет с недавними ордерами (`IncomingOrder`/`OrderHistory`), ключевые KPI (если применимо).
    *   `pages/Stores.tsx`: Таблица со списком магазинов мерчанта (`MerchantStore[]`). Возможность просмотра деталей, управления статусами (`is_active`), лимитами (`limits`), настройками коллбэков. **Безопасное** управление API ключами (генерация/просмотр ID/обновление секрета без повторного показа секрета).
    *   `pages/StoreCreate.tsx` / `pages/StoreEdit.tsx`: Формы для создания/редактирования магазина.
    *   `pages/Orders.tsx`: Таблица с историей ордеров (`IncomingOrder[]`, `OrderHistory[]`), включая фильтры (по дате, статусу, магазину), пагинацию. Обновление статусов через SSE.
    *   `pages/ProfileSettings.tsx`: Настройки профиля пользователя-мерчанта.
    *   `pages/ApiDocs.tsx`: (Возможно) Встроенная или ссылка на документацию по API для интеграции.
*   **API/SSE/Типы:** Использование типизированных запросов к эндпоинтам `/api/merchant/*`, обработка SSE-сообщений для ордеров.

### 3.2. Приложение Трейдера (`frontend/trader_app/`)
*   **Ключевая задача:** Обеспечить эффективное управление реквизитами и их настройками, оперативное получение информации о новых назначенных ордерах (через SSE) и отслеживание истории балансов.
*   **Детализация страниц:**
    *   `pages/Dashboard.tsx`: Отображение текущих балансов (`BalanceTrader[]`), статуса работы (`is_active`), количества активных/назначенных ордеров, KPI производительности.
    *   `pages/Requisites.tsx`: Таблица со списком реквизитов трейдера (`ReqTrader[]`) с их статусами (`status`). Форма добавления нового реквизита. Модальные окна для редактирования настроек (`FullRequisitesSettings`, включая лимиты, валюты, время работы).
    *   `pages/AssignedOrders.tsx`: Таблица с назначенными ордерами (`OrderHistory[]`), требующими обработки. Обновления через SSE при назначении нового ордера. Механизм подтверждения/обработки ордера (уточнить логику).
    *   `pages/BalanceHistory.tsx`: Раздельные таблицы или вкладки для истории фиатных (`BalanceTraderFiatHistory[]`) и крипто (`BalanceTraderCryptoHistory[]`) балансов с фильтрами.
    *   `pages/ProfileSettings.tsx`: Настройки профиля пользователя-трейдера.
*   **API/SSE/Типы:** Использование типизированных запросов к `/api/trader/*`, обработка SSE для новых ордеров.

### 3.3. Приложение Администратора (`frontend/admin_app/`)
*   **Ключевая задача:** Предоставить полный контроль над системой: управление пользователями всех ролей, магазинами, реквизитами (включая модерацию), просмотр всех ордеров, настройка системных параметров и справочников.
*   **Детализация страниц:**
    *   `pages/Dashboard.tsx`: Агрегированная статистика по системе (объемы, количество пользователей, активные ордера и т.д.).
    *   `pages/Users/Merchants.tsx`, `pages/Users/Traders.tsx`, `pages/Users/Supports.tsx`, `pages/Users/Admins.tsx`: Таблицы со списками пользователей соответствующей роли. Возможность создания, редактирования, блокировки, управления правами доступа (для саппортов/админов).
    *   `pages/Stores.tsx`: Обзор **всех** магазинов (`MerchantStore[]`) с возможностью фильтрации, просмотра деталей, управления статусом (административного).
    *   `pages/Requisites.tsx`: Обзор **всех** реквизитов (`ReqTrader[]`) с возможностью фильтрации, просмотра деталей и настроек (`FullRequisitesSettings`), **одобрения/отклонения** новых реквизитов (изменение `ReqTrader.status`).
    *   `pages/Orders.tsx`: Обзор **всех** ордеров (`IncomingOrder[]`, `OrderHistory[]`) с мощными фильтрами (по пользователям, магазинам, трейдерам, реквизитам, статусам, датам).
    *   `pages/SystemSettings/ReferenceData.tsx`: Интерфейс для управления системными справочниками (валюты, платежные системы, настройки комиссий и т.п. - согласно `db.py` и `ReferenceService`).
    *   `pages/SystemSettings/SystemStatus.tsx`: (Возможно) Мониторинг состояния ключевых компонентов системы.
    *   `pages/ProfileSettings.tsx`: Настройки профиля администратора.
*   **API/SSE/Типы:** Использование типизированных запросов к `/api/admin/*`. SSE может использоваться для уведомлений о событиях, требующих внимания (например, новые реквизиты на модерацию).

### 3.4. Приложение Саппорта (`frontend/support_app/`)
*   **Ключевая задача:** Обеспечить быстрый поиск и просмотр информации по ордерам и пользователям для решения возникающих вопросов, с учетом разграничения прав доступа.
*   **Детализация страниц:** Функционал зависит от прав доступа (`access_to` в `SupportUser`).
    *   `pages/Dashboard.tsx` / `pages/Search.tsx`: Основной инструмент - универсальный поиск по ID ордера, ID пользователя, email, ID магазина и т.д.
    *   `pages/OrderSearch.tsx`: Результаты поиска по ордерам.
    *   `pages/OrderDetailViewer.tsx`: Детальный просмотр ордера (`IncomingOrder`/`OrderHistory`) со связанными данными (пользователь, магазин, трейдер, реквизиты) - **только чтение**.
    *   `pages/UserSearch.tsx`: Результаты поиска по пользователям.
    *   `pages/UserDetailViewer.tsx`: Детальный просмотр пользователя (Мерчант/Трейдер) с его данными (магазины/реквизиты) - **только чтение**.
    *   `pages/ProfileSettings.tsx`: Настройки профиля саппорта.
*   **API/Типы:** Использование типизированных запросов к `/api/support/*`. Права доступа проверяются на бэкенде.

--- 

## 4. Общие Компоненты, Типы, Утилиты и Конфигурации

**Стратегии Переиспользования:**

1.  **Монорепозиторий с общими пакетами (Рекомендуется, с использованием PNPM Workspaces и Turborepo):**
    *   **Инструменты:** Рекомендуется использовать **PNPM** для управления зависимостями (эффективно работает с дисковым пространством и `node_modules`) и **Turborepo** для оркестрации задач (сборка, тестирование, линтинг) и их кэширования, что значительно ускоряет CI/CD и локальную разработку.
    *   **Преимущества:** Централизованное управление зависимостями, атомарные коммиты изменений в общем коде и его потребителях, упрощение рефакторинга, легкая локальная разработка и тестирование общих пакетов, оптимизированные скрипты и сборка.
    *   **Пакеты:**
        *   `packages/ui-kit`: Компоненты UI. **Важно:** Рекомендуется **на раннем этапе определиться с базовой UI библиотекой** (например, Material UI (MUI), Ant Design, Chakra UI, Headless UI + Tailwind CSS) или явно принять решение о разработке полностью кастомной библиотеки. Выбранная библиотека станет основой для `ui-kit`. `ui-kit` должен экспортировать не только обертки над базовыми компонентами (Button, Input, Table), но и кастомные, специфичные для домена компоненты (например, `OrderStatusBadge`, `RequisiteCard`), а также **общий провайдер темы** для гарантии визуальной консистентности во всех приложениях.
        *   `packages/types`: Генерируемые TypeScript типы. Централизация гарантирует консистентность.
        *   `packages/utils`: Функции, не имеющие зависимостей от UI или состояния конкретного приложения.
        *   `packages/hooks`: Переиспользуемые хуки (например, для работы с `localStorage`, форматирования, возможно, даже обертки над API, если структура запросов схожа).
        *   `packages/config`: Общие конфигурации ESLint, Prettier, TSConfig (`tsconfig.base.json`, от которого наследуются конфиги приложений).
        *   `packages/i18n`: Общие файлы переводов и конфигурация `i18next`.
2.  **Отдельные npm-пакеты:**
    *   **Преимущества:** Четкое версионирование общих частей, возможность использования разными командами/репозиториями.
    *   **Недостатки:** Сложнее управление зависимостями (проблемы версий), синхронизация изменений требует публикации и обновления во всех приложениях, усложнение локальной разработки.
3.  **Дублирование:**
    *   **Преимущества:** Простота на самом старте.
    *   **Недостатки:** Быстро приводит к рассинхронизации, увеличению трудозатрат на поддержку и исправление багов в одинаковом коде в разных местах. Не рекомендуется.

**Обработка Ошибок (Единый подход):**
*   **Цель:** Предоставить пользователю понятную обратную связь и собрать максимум информации для разработчиков.
*   **Реализация:** Централизованный обработчик в API-клиенте.
    *   **4xx ошибки (Bad Request, Unauthorized, Forbidden, Not Found...):** Часто требуют специфической обработки в UI (показать сообщение об ошибке валидации формы, перенаправить на логин, показать "не найдено"). Обработчик может пробрасывать типизированные ошибки дальше.
    *   **5xx ошибки (Internal Server Error...):** Обычно означают проблему на бэкенде. Следует показать пользователю общее сообщение ("Что-то пошло не так, попробуйте позже") и **обязательно** отправить детали ошибки в систему мониторинга (Sentry) с контекстом запроса.
*   **Sentry (или аналог):** Интеграция как для ошибок API (5xx), так и для неперехваченных ошибок JavaScript в самом фронтенд-приложении.

**Тестирование:**
*   **Unit-тесты (`jest`, `vitest`):** Проверка чистых функций (утилиты, редьюсеры), кастомных хуков. Быстрые и изолированные.
*   **Компонентные тесты (`testing-library`, Storybook/Ladle):** Тестирование UI-компонентов в изоляции, проверка рендеринга, взаимодействия, доступности. Visual regression тесты помогают отслеживать непреднамеренные визуальные изменения.
*   **Интеграционные тесты (`testing-library`):** Проверка взаимодействия нескольких компонентов или пользовательских сценариев в рамках *одного* приложения (например, заполнение формы и отправка запроса, рендеринг списка после загрузки данных).
*   **E2E тесты (`cypress`, `playwright`):** Тестирование полных пользовательских сценариев в браузере, включая взаимодействие с бэкендом. Дорогие в написании и поддержке, но дают наибольшую уверенность.

--- 

## 5. Сборка, Развертывание и Следующие Шаги

**Сборка и Развертывание:**
*   **Монорепо:** CI/CD пайплайн должен уметь определять измененные приложения/пакеты и запускать сборку/развертывание только для них.
*   **Хостинг:** Размещение на отдельных поддоменах (`merchant.jivapay.com`, `admin.jivapay.com`) часто предпочтительнее для изоляции и упрощения конфигурации CDN/кэширования, чем размещение на разных путях одного домена (`jivapay.com/merchant`).
*   **Окружения:** Наличие отдельных окружений для разработки, тестирования (staging) и продакшена с соответствующими `.env` файлами и настройками бэкенда.
*   **Инфраструктурная Безопасность:** Настройка и **обязательная** конфигурация выбранных средств защиты от DDoS (CDN/WAF/облачные сервисы) перед выводом приложений в продуктивное использование. Настройка правил Rate Limiting на уровне API Gateway или бэкенд-сервисов.

**Следующие Шаги:**
*(Шаги остаются прежними, но теперь с большим пониманием контекста)*
1.  Окончательный выбор стека (**включая базовую UI библиотеку**), стратегии переиспользования.
2.  Настройка инфраструктуры монорепозитория (если выбрано, **с использованием PNPM/Turborepo**) и **базового CI/CD**. 
    *   **CI/CD для Frontend:** Настроить пайплайн (GitHub Actions и т.п.) для запуска линтеров (ESLint, Prettier), проверки типов (TSC), юнит/компонентных тестов (Jest/Vitest/Testing Library) и сборки измененных приложений/пакетов (особенно важно для монорепозитория с Turborepo).
3.  Настройка генерации типов из OpenAPI и общих пакетов (`types`, `ui-kit`, `utils`, `hooks`, `config`, `i18n`).
4.  Реализация базовых слоев (аутентификация, layout, API-клиент, обработка ошибок, i18n) в каждом приложении или общих пакетах.
5.  Итеративная разработка функционала по ролям с написанием тестов.
6.  Интеграция SSE.
7.  Проверка доступности, безопасности.
8.  UI/UX ревью и полировка.

--- 

## 6. Платежный Шлюз (Frontend)

*   **Назначение:** Предоставить пользовательский интерфейс для конечных клиентов магазинов для проведения оплаты (Pay-In) или запроса выплаты (Pay-Out).
*   **Варианты реализации:**
    1.  **Хостируемая Страница Оплаты (Hosted Payment Page - HPP):**
        *   **Описание:** JivaPay хостит отдельную веб-страницу (или набор страниц), на которую мерчант перенаправляет своего клиента.
        *   **Плюсы:** Простая интеграция для мерчанта (только редирект с параметрами), полный контроль над UI/UX у JivaPay, проще обеспечить безопасность.
        *   **Минусы:** Менее бесшовный опыт для клиента (уход с сайта мерчанта), сложнее кастомизировать под бренд мерчанта.
        *   **Реализация:** Отдельное небольшое React/Vue/etc. приложение или набор серверных шаблонов, взаимодействующее с `backend/api_routers/gateway.py`.
    2.  **Платежный Виджет (Payment Widget):**
        *   **Описание:** JavaScript-код, который мерчант встраивает на свою страницу оформления заказа. Виджет отрисовывает необходимые элементы интерфейса (выбор метода, ввод данных, загрузка чека) внутри страницы мерчанта (например, в iframe или напрямую).
        *   **Плюсы:** Более бесшовный UX, потенциально больше возможностей кастомизации.
        *   **Минусы:** Более сложная интеграция для мерчанта, потенциальные проблемы с безопасностью (CORS, XSS), необходимость тщательного тестирования на сайтах мерчантов.
        *   **Реализация:** JavaScript-библиотека, которая взаимодействует с `backend/api_routers/gateway.py` и управляет своим UI.
*   **Рекомендация:** Начать с **Хостируемой Страницы Оплаты (HPP)** как более простого и контролируемого варианта. В дальнейшем можно разработать Виджет.
*   **Ключевые Компоненты UI (для HPP):**
    *   Форма инициации:
        *   Выбор метода оплаты, банка.
        *   Поле для ввода суммы: Отображается, **только если** сумма не была передана мерчантом в параметрах редиректа **И** настройка магазина `gateway_require_amount_param` равна `False`.
        *   Поле для ввода ID клиента магазина (`customer_id`): Отображается, **только если** `customer_id` не был передан мерчантом в параметрах **И** настройка магазина `gateway_require_customer_id_param` равна `False`.
    *   Отображение деталей подобранного реквизита.
    *   Поле для загрузки чека/скриншота.
    *   Кнопки подтверждения/отмены.
    *   Отображение статуса операции (ожидание, успех, ошибка).
    *   Автоматический редирект на `return_url` по завершению.

## 7. Стратегии Повторного Использования Кода (Multi-App)

Этот наиболее детализированный план предоставляет комплексное видение архитектуры фронтенда, учитывая как технические аспекты, так и процессы разработки и поддержки. 