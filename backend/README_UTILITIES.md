# Документация по утилитам backend

---

## 1. Общее Описание

Этот документ описывает набор утилит и вспомогательных модулей в директории `backend`, разработанных для реализации основной логики платежной системы JivaPay, описанной в `README_DB.md`. Эти утилиты обеспечивают надежное взаимодействие с базой данных, асинхронную обработку входящих заявок, подбор реквизитов, учет балансов, обработку ошибок и другие ключевые операции, направленные на создание **отказоустойчивой** и **надежной** системы.

Структура утилит ориентирована на поддержку асинхронной обработки заявок и транзакционной целостности данных.

---

## 2. Ключевые Утилиты и Модули

### 2.1. Утилиты для работы с Базой Данных (`database.utils` или аналогичный)

*   **Назначение:** Предоставление высокоуровневых, безопасных и отказоустойчивых функций для взаимодействия с моделями SQLAlchemy, управление сессиями и транзакциями.
*   **Основные функции:**
    *   `get_db_session()`: Утилита для получения сессии БД с использованием менеджера контекста (`contextlib.contextmanager`), гарантирующая закрытие сессии даже при ошибках. Должна включать обработку ошибок подключения к БД с логированием и, возможно, политикой повторных попыток подключения при инициализации.
    *   `atomic_transaction()`: Декоратор или менеджер контекста для выполнения блока кода в рамках атомарной транзакции. **Ключевая особенность:** автоматический ROLLBACK при любом исключении внутри блока и COMMIT при успешном завершении. Должен логировать начало, успех (COMMIT) и неудачу (ROLLBACK с причиной/исключением).
    *   CRUD-функции (например, `create_object`, `get_object_by_id`, `update_object`, `delete_object`): Обертки над стандартными операциями SQLAlchemy, включающие:
        *   Обработку специфичных исключений SQLAlchemy (например, `IntegrityError`, `NoResultFound`).
        *   Логирование операций и ошибок.
        *   Возможно, стандартизированные возвращаемые значения или кастомные исключения для единообразной обработки на верхних уровнях.

### 2.2. Логика подбора Реквизитов (`services.requisite_selector` или аналогичный)

*   **Назначение:** Инкапсуляция **критически важной** и сложной логики поиска и выбора подходящего реквизита трейдера. Должна быть **максимально надежной и транзакционно безопасной**.
*   **Основные функции:**
    *   `find_suitable_requisite(incoming_order: IncomingOrder, db_session: Session)`: Основная функция, принимающая **объект входящей заявки** и **активную сессию БД**. Работает **внутри транзакции**, управляемой извне (например, из `order_processor`).
    *   **Внутренняя логика:**
        *   Загрузка связанных данных (настроек `FullRequisitesSettings`, данных трейдера) в рамках той же сессии.
        *   Выполнение **оптимизированного** SQL-запроса с JOIN, фильтрами и сортировкой. Использует `with_for_update(skip_locked=True)` для неблокирующего выбора кандидата при высокой конкуренции.
        *   **Обработка сценариев:**
            *   **Кандидат не найден:** Возвращает специальный статус или `None`, логирует причину (нет подходящих по статическим параметрам).
            *   **Кандидат найден и заблокирован:**
                *   Проверка динамических лимитов: Выполняет агрегирующие запросы к `order_history` **в той же транзакции** для расчета текущего оборота.
                *   **Лимит превышен:** Освобождает блокировку (неявно при завершении транзакции без COMMIT), возвращает статус о превышении лимита, логирует детали.
                *   **Все проверки пройдены:** Возвращает ID найденного и **заблокированного** реквизита и трейдера.
        *   **Обработка ошибок:** Любые ошибки запросов к БД должны перехватываться, логироваться и приводить к откату транзакции на вызывающем уровне.

### 2.3. Обработка Входящих Заявок (`services.order_processor` или аналогичный)

*   **Назначение:** Оркестрация процесса обработки одной входящей заявки, координация подбора реквизита, создание ордера и обновление статусов с **гарантией атомарности**.
*   **Основные функции:**
    *   `process_incoming_order(incoming_order_id: int)`: Главная функция, вызываемая Worker'ом.
    *   **Внутренняя логика:**
        1.  Получение сессии БД (`get_db_session`).
        2.  **Начало атомарной транзакции** (`atomic_transaction`).
        3.  Загрузка `IncomingOrder` по ID **с блокировкой записи** (`with_for_update`) для предотвращения двойной обработки. Проверка текущего статуса (должен быть 'new' или 'retrying'). Если статус другой - выход.
        4.  Вызов `find_suitable_requisite`, передача объекта заявки и сессии.
        5.  **Анализ результата `find_suitable_requisite`:**
            *   **Успех (кандидат найден):**
                *   Расчет комиссии трейдера (с обработкой ошибок, если настройки не найдены).
                *   Создание новой записи в `order_history`.
                *   Обновление `incoming_orders`: `status='assigned'`, `assigned_order_id`, `failure_reason=None`.
                *   **COMMIT транзакции** (выполняется менеджером `atomic_transaction`).
                *   Логирование успеха.
            *   **Неудача (кандидат не найден / лимит превышен):**
                *   Определение, является ли ошибка временной (можно повторить) или постоянной.
                *   Обновление `incoming_orders`: увеличение `retry_count`, `last_attempt_at`, запись `failure_reason`. Установка статуса `'retrying'` (если `retry_count` < max_retries) или `'failed'` (если превышен лимит попыток или ошибка постоянная).
                *   **ROLLBACK транзакции** (выполняется менеджером `atomic_transaction` при выходе из блока без успеха или при исключении).
                *   Логирование неудачи с причиной.
            *   **Исключение внутри `find_suitable_requisite` или при обновлении БД:**
                *   Менеджер `atomic_transaction` выполнит **ROLLBACK**.
                *   Обновление `incoming_orders` (в отдельной сессии или перед ROLLBACK основной): увеличение `retry_count`, `last_attempt_at`, запись `failure_reason` (текст исключения), статус `'retrying'` или `'failed'`.
                *   Логирование критической ошибки.
        6.  **Важно:** Обеспечить, чтобы обновление статуса `incoming_orders` при неудачах происходило **надежно**, даже если основная транзакция откатывается. Это может потребовать отдельной сессии для обновления статуса или выполнения обновления до ROLLBACK основной транзакции.

### 2.4. Фоновый Обработчик (Worker - `worker.order_processing` или аналогичный)

*   **Назначение:** **Отказоустойчивый** сервис для непрерывного выбора и запуска обработки заявок из очереди `incoming_orders`.
*   **Реализация:** Может быть реализован с использованием Celery, Dramatiq, asyncio или другого подходящего инструмента для фоновых задач.
*   **Логика:**
    *   **Выборка задач:** Периодически или по триггеру опрашивает `incoming_orders` на наличие записей со статусом `'new'` или `'retrying'` (где `last_attempt_at` + backoff_delay < now). Запрос должен быть **эффективным** (использовать индексы `ix_incoming_orders_status_created`).
    *   **Распределение:** Передает ID выбранных заявок в `process_incoming_order` (например, как задачи для Celery/Dramatiq worker'ов).
    *   **Обработка ошибок на уровне Worker'а:**
        *   Перехват **любых** исключений при выборке задач или запуске обработки.
        *   Логирование критических ошибок Worker'а.
        *   Реализация стратегии перезапуска Worker'а при сбоях.
        *   **Механизм Backoff:** При статусе `'retrying'` использовать экспоненциальную задержку (`last_attempt_at` + `retry_count` * backoff_factor) перед следующей попыткой.
        *   **Dead Letter Queue (DLQ):** Задачи, которые не удалось обработать после максимального числа попыток (статус `'failed'`), должны либо оставаться в БД для ручного анализа, либо перемещаться в отдельную "очередь мертвых писем" (если используется система очередей).
    *   **Мониторинг:** Worker должен предоставлять метрики (длина очереди, время обработки, количество ошибок) для систем мониторинга.

### 2.5. Утилиты для работы с Балансами и Комиссиями (`services.balance_manager` или аналогичный)

*   **Назначение:** **Надежное** обновление балансов и запись истории. Выполняется **после** успешного подтверждения выполнения ордера (статус `completed` в `order_history`), а не сразу после назначения реквизита.
*   **Основные функции:**
    *   `update_balances_for_completed_order(order_id: int)`:
        *   Работает в **атомарной транзакции**.
        *   Загружает `OrderHistory` и связанные `MerchantStore`, `Trader`.
        *   **Блокирует** строки балансов (`balance_stores`, `balance_traders`) для обновления (`FOR UPDATE`).
        *   Обновляет `balance` в `balance_stores` и `balance_traders`.
        *   Создает записи в `balance_store_history`, `balance_trader_fiat_history`, `balance_trader_crypto_history`.
        *   Обрабатывает возможные ошибки (например, недостаточный баланс, если это применимо), логирует и откатывает транзакцию.
    *   `calculate_commissions(order_details)`: Рассчитывает комиссии. Должна обрабатывать случаи отсутствия настроек комиссий (использовать значения по умолчанию или вызывать ошибку).

### 2.6. Утилиты для работы со Справочниками (`services.reference_data` или аналогичный)

*   **Назначение:** Предоставление доступа к справочным данным с **кэшированием** и обработкой ошибок.
*   **Основные функции:**
    *   Функции `get_...`: `get_exchange_rate`, `get_fiat_currency_details`, `get_payment_method_details` и т.д.
    *   **Кэширование:** Реализовать кэширование часто запрашиваемых справочных данных (например, курсов валют, списка банков) для снижения нагрузки на БД (использовать Redis, Memcached или кэш в памяти с TTL).
    *   **Обработка ошибок:** Если данные не найдены в справочнике (например, неверный ID), возвращать `None` или выбрасывать специфическое исключение. Логировать такие случаи. При ошибках получения данных из внешних источников (например, курсов) – использовать последние кэшированные значения или возвращать ошибку, если кэш пуст/устарел.

### 2.7. Утилиты Обработки Ошибок и Оповещений (`services.error_handler` или `utils.notifications`)

*   **Назначение:** Централизованная обработка и классификация ошибок, отправка оповещений.
*   **Компоненты:**
    *   **Кастомные классы исключений:** Определить иерархию исключений для бизнес-логики (например, `RequisiteNotFound`, `LimitExceeded`, `InsufficientBalance`, `ConfigurationError`).
    *   **Централизованный логгер ошибок:** Конфигурируется в `config.logger`.
    *   **Интеграция с системой мониторинга/оповещений:** Отправка критических ошибок (например, сбои Worker'а, ошибки транзакций, большое кол-во заявок в статусе 'failed') в Sentry, Prometheus/Alertmanager, PagerDuty и т.д.
    *   `report_critical_error(exception, context)`: Функция для отправки отчета об ошибке во внешние системы.

---

## 3. Взаимосвязь и Поток Данных (с учетом ошибок)

1.  **API Запрос (PayIn/PayOut):** Создает `IncomingOrder` ('new') через `database.utils`. Ошибка здесь -> HTTP 500 клиенту.
2.  **Worker:** Выбирает заявку ('new'/'retrying'). Ошибка Worker'а -> Лог, Alert, перезапуск Worker'а.
3.  **Worker -> `order_processor`:** Запускает обработку.
4.  **`order_processor`:** Начинает транзакцию, блокирует `IncomingOrder`.
5.  **`order_processor` -> `requisite_selector`:** Ищет реквизит.
    *   **Успех:** Возвращает `requisite_id`.
    *   **Не найден/Лимит:** Возвращает статус -> `order_processor` обновляет `IncomingOrder` ('retrying'/'failed'), ROLLBACK.
    *   **Ошибка БД:** Исключение -> `order_processor` перехватывает, обновляет `IncomingOrder` ('retrying'/'failed'), ROLLBACK.
6.  **`order_processor` (если реквизит найден):** Создает `OrderHistory`, обновляет `IncomingOrder` ('assigned').
    *   **Успех:** COMMIT.
    *   **Ошибка БД:** Исключение -> `order_processor` перехватывает, пытается обновить `IncomingOrder` ('retrying'/'failed'), ROLLBACK.
7.  **(Позже) Система подтверждения ордера:** Обновляет `OrderHistory.status` на 'completed'/'failed'/'cancelled'.
8.  **(При 'completed') -> `balance_manager`:** Обновляет балансы и историю в транзакции. Ошибка -> Лог, Alert, ROLLBACK (требуется механизм повторной попытки или ручного вмешательства для обновления балансов).

---

## 4. Ключевые Аспекты Отказоустойчивости

*   **Атомарность:** Все критические изменения состояния (назначение реквизита, создание ордера, обновление балансов) должны происходить в рамках атомарных транзакций.
*   **Идемпотентность:** По возможности, операции обработки (особенно `process_incoming_order`) должны быть идемпотентными или иметь механизм предотвращения двойной обработки (через блокировки `FOR UPDATE`).
*   **Обработка сбоев Worker'а:** Worker должен быть перезапускаемым и уметь продолжать обработку с того места, где остановился, корректно обрабатывая статусы 'new' и 'retrying'.
*   **Повторные попытки (Retry):** Четкая логика повторных попыток с экспоненциальной задержкой (backoff) для временных ошибок.
*   **Четкие статусы:** Использование статусов в `incoming_orders` и `order_history` для точного отслеживания состояния обработки.
*   **Логирование:** Подробное логирование всех шагов, особенно ошибок и решений, принимаемых системой.
*   **Мониторинг и Оповещения:** Непрерывный мониторинг ключевых метрик (длина очереди, % ошибок, время обработки) и немедленное оповещение о критических сбоях.
*   **Конфигурация:** Вынесение параметров (max_retries, backoff_factor, таймауты) в конфигурационные файлы или переменные окружения.

---

Эта расширенная документация закладывает основу для построения действительно надежной и отказоустойчивой системы обработки платежей.

---

Эта документация представляет собой высокоуровневое описание необходимых утилит для реализации основной логики системы. Детальная реализация каждого модуля будет описана в соответствующих файлах исходного кода и, при необходимости, в отдельных README. 