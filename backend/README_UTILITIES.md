# Документация по утилитам backend

---

## 1. Общее Описание

Этот документ описывает набор утилит и вспомогательных модулей в директории `backend`, разработанных для реализации основной логики платежной системы JivaPay, описанной в `README_DB.md`. Эти утилиты обеспечивают надежное взаимодействие с базой данных, асинхронную обработку входящих заявок, подбор реквизитов, учет балансов, обработку ошибок и другие ключевые операции, направленные на создание **отказоустойчивой** и **надежной** системы.

Структура утилит ориентирована на поддержку асинхронной обработки заявок и транзакционной целостности данных.

---

## 2. Ключевые Утилиты и Модули

### 2.1. Утилиты для работы с Базой Данных (`database.utils` или аналогичный)

*   **Назначение:** Предоставление высокоуровневых, безопасных и отказоустойчивых функций для взаимодействия с моделями SQLAlchemy, управление сессиями и транзакциями.
*   **Основные функции:**
    *   `get_db_session()`: Утилита для получения сессии БД с использованием менеджера контекста (`contextlib.contextmanager`), гарантирующая закрытие сессии даже при ошибках. Должна включать обработку ошибок подключения к БД с логированием и, возможно, политикой повторных попыток подключения при инициализации.
    *   `atomic_transaction()`: Декоратор или менеджер контекста для выполнения блока кода в рамках атомарной транзакции. **Ключевая особенность:** автоматический ROLLBACK при любом исключении внутри блока и COMMIT при успешном завершении. Должен логировать начало, успех (COMMIT) и неудачу (ROLLBACK с причиной/исключением).
    *   CRUD-функции (например, `create_object`, `get_object_by_id`, `update_object`, `delete_object`): Обертки над стандартными операциями SQLAlchemy, включающие:
        *   Обработку специфичных исключений SQLAlchemy (например, `IntegrityError`, `NoResultFound`).
        *   Логирование операций и ошибок.
        *   Возможно, стандартизированные возвращаемые значения или кастомные исключения для единообразной обработки на верхних уровнях.

### 2.2. Логика подбора Реквизитов (`services.requisite_selector` или аналогичный)

*   **Назначение:** Инкапсуляция **критически важной** и сложной логики поиска и выбора подходящего реквизита трейдера. Должна быть **максимально надежной и транзакционно безопасной**.
*   **Основные функции:**
    *   `find_suitable_requisite(incoming_order: IncomingOrder, db_session: Session)`: Основная функция, принимающая **объект входящей заявки** и **активную сессию БД**. Работает **внутри транзакции**, управляемой извне (например, из `order_processor`).
    *   **Внутренняя логика:**
        *   Загрузка связанных данных (настроек `FullRequisitesSettings`, данных трейдера) в рамках той же сессии.
        *   Выполнение **оптимизированного** SQL-запроса с JOIN, фильтрами и сортировкой. Использует `with_for_update(skip_locked=True)` для неблокирующего выбора кандидата при высокой конкуренции.
        *   **Обработка сценариев:**
            *   **Кандидат не найден:** Возвращает специальный статус или `None`, логирует причину (нет подходящих по статическим параметрам).
            *   **Кандидат найден и заблокирован:**
                *   Проверка динамических лимитов: Выполняет агрегирующие запросы к `order_history` **в той же транзакции** для расчета текущего оборота.
                *   **Лимит превышен:** Освобождает блокировку (неявно при завершении транзакции без COMMIT), возвращает статус о превышении лимита, логирует детали.
                *   **Все проверки пройдены:** Возвращает ID найденного и **заблокированного** реквизита и трейдера.
        *   **Обработка ошибок:** Любые ошибки запросов к БД должны перехватываться, логироваться и приводить к откату транзакции на вызывающем уровне.

### 2.3. Обработка Входящих Заявок (`services.order_processor` или аналогичный)

*   **Назначение:** Оркестрация процесса обработки одной входящей заявки, координация подбора реквизита, создание ордера и обновление статусов с **гарантией атомарности** и **надежной фиксацией результата**.
*   **Основные функции:**
    *   `process_incoming_order(incoming_order_id: int)`: Главная функция, вызываемая Worker'ом.
    *   **Внутренняя логика:**
        1.  **Проверка идемпотентности:** Перед началом основной логики проверить, не была ли заявка с `incoming_order_id` уже успешно обработана (например, проверить наличие `OrderHistory` с `incoming_order_id` или статус `IncomingOrder`). Если да - просто выйти (или вернуть подтверждение).
        2.  Получение сессии БД (`get_db_session`).
        3.  **Начало основной атомарной транзакции** (`atomic_transaction`).
        4.  Загрузка `IncomingOrder` по ID **с блокировкой записи** (`with_for_update`) для предотвращения двойной обработки *параллельными* воркерами. Проверка текущего статуса (должен быть 'new' или 'retrying'). Если статус другой (уже 'assigned' или 'failed') - выход (транзакция откатится).
        5.  **Вызов Fraud Detection:** `fraud_detector.check_incoming_order(...)`. Обработка результата (`DENY` -> переход к шагу "Надежное обновление статуса"; `REQUIRE_MANUAL_REVIEW` -> аналогично, но с другим статусом).
        6.  Вызов `find_suitable_requisite`, передача объекта заявки и сессии.
        7.  **Анализ результата `find_suitable_requisite`:**
            *   **Успех (кандидат найден):**
                *   Расчет комиссии трейдера (с обработкой ошибок, если настройки не найдены).
                *   Создание новой записи в `order_history` (с фиксацией курса).
                *   Обновление `incoming_orders`: `status='assigned'`, `assigned_order_id`, `failure_reason=None`.
                *   **COMMIT основной транзакции** (выполняется менеджером `atomic_transaction`).
                *   Логирование успеха.
            *   **Неудача (кандидат не найден / лимит превышен / фрод):**
                *   Менеджер `atomic_transaction` выполнит **ROLLBACK** основной транзакции при выходе из блока без успеха.
                *   **Надежное обновление статуса IncomingOrder (вне основной транзакции):**
                    *   Получить **новую сессию БД**.
                    *   Начать **новую атомарную транзакцию**.
                    *   Загрузить `IncomingOrder` (уже без блокировки).
                    *   Определить, является ли ошибка временной (можно повторить) или постоянной.
                    *   Обновить `incoming_orders`: увеличение `retry_count`, `last_attempt_at`, запись `failure_reason`. Установка статуса `'retrying'` (если `retry_count` < max_retries) или `'failed'`.
                    *   **COMMIT** транзакции обновления статуса.
                    *   Логировать неуспех обновления статуса, если он произошел.
                *   Логирование неудачи основной обработки с причиной.
            *   **Исключение внутри основной транзакции:**
                *   Менеджер `atomic_transaction` выполнит **ROLLBACK** основной транзакции.
                *   **Надежное обновление статуса IncomingOrder (вне основной транзакции):** (Аналогично предыдущему пункту)
                    *   Получить **новую сессию БД**.
                    *   Начать **новую атомарную транзакцию**.
                    *   Загрузить `IncomingOrder`.
                    *   Обновить `incoming_orders`: увеличение `retry_count`, `last_attempt_at`, запись `failure_reason` (текст исключения), статус `'retrying'` или `'failed'`. 
                    *   **COMMIT** транзакции обновления статуса.
                    *   Логировать неуспех обновления статуса.
                *   Логирование критической ошибки основной обработки.
                *   Отправка оповещения (`report_critical_error`), если необходимо.

**Ключевое требование:** Обновление статуса `IncomingOrder` на `retrying` или `failed` должно происходить **надежно и изолированно** от основной транзакции обработки, чтобы гарантировать корректную работу механизма повторных попыток Worker'а и предотвратить бесконечную обработку сбойных заявок.

### 2.4. Фоновый Обработчик (Worker - `worker.order_processing` или аналогичный)

*   **Назначение:** **Отказоустойчивый** сервис для непрерывного выбора и запуска обработки заявок из очереди `incoming_orders`.
*   **Реализация:** Может быть реализован с использованием Celery, Dramatiq, asyncio или другого подходящего инструмента для фоновых задач.
*   **Логика:**
    *   **Выборка задач:** Периодически или по триггеру опрашивает `incoming_orders` на наличие записей со статусом `'new'` или `'retrying'` (где `last_attempt_at` + backoff_delay < now). Запрос должен быть **эффективным** (использовать индексы `ix_incoming_orders_status_created`).
    *   **Распределение:** Передает ID выбранных заявок в `process_incoming_order` (например, как задачи для Celery/Dramatiq worker'ов).
    *   **Обработка ошибок на уровне Worker'а:**
        *   Перехват **любых** исключений при выборке задач или запуске обработки.
        *   Логирование критических ошибок Worker'а.
        *   Реализация стратегии перезапуска Worker'а при сбоях.
        *   **Механизм Backoff:** При статусе `'retrying'` использовать экспоненциальную задержку (`last_attempt_at` + `retry_count` * backoff_factor) перед следующей попыткой.
        *   **Dead Letter Queue (DLQ):** Задачи, которые не удалось обработать после максимального числа попыток (статус `'failed'`), должны либо оставаться в БД для ручного анализа, либо перемещаться в отдельную "очередь мертвых писем" (если используется система очередей).
    *   **Мониторинг:** Worker должен предоставлять метрики (длина очереди, время обработки, количество ошибок) для систем мониторинга.

### 2.5. Утилиты для работы с Балансами и Комиссиями (`services.balance_manager` или аналогичный)

*   **Назначение:** **Надежное** обновление балансов и запись истории. Выполняется **после** успешного подтверждения выполнения ордера (статус `completed` в `order_history`), а не сразу после назначения реквизита.
*   **Основные функции:**
    *   `update_balances_for_completed_order(order_id: int)`:
        *   Работает в **атомарной транзакции**.
        *   Загружает `OrderHistory` и связанные `MerchantStore`, `Trader`.
        *   **Блокирует** строки балансов (`balance_stores`, `balance_traders`) для обновления (`FOR UPDATE`).
        *   Обновляет `balance` в `balance_stores` и `balance_traders`.
        *   Создает записи в `balance_store_history`, `balance_trader_fiat_history`, `balance_trader_crypto_history`.
        *   Обрабатывает возможные ошибки (например, недостаточный баланс, если это применимо), логирует и откатывает транзакцию.
    *   `calculate_commissions(order_details)`: Рассчитывает комиссии. Должна обрабатывать случаи отсутствия настроек комиссий (использовать значения по умолчанию или вызывать ошибку).

### 2.6. Утилиты для работы со Справочниками (`services.reference_data` или аналогичный)

*   **Назначение:** Предоставление доступа к справочным данным с **кэшированием** и обработкой ошибок.
*   **Основные функции:**
    *   Функции `get_...`: `get_exchange_rate`, `get_fiat_currency_details`, `get_payment_method_details` и т.д.
    *   **Курсы Валют (`get_exchange_rate`):**
        *   **Источник:** Необходимо определить источник курсов (например, API внешнего провайдера типа Binance, CoinMarketCap, или внутренний механизм установки курсов администратором).
        *   **Обновление:** Данные должны регулярно обновляться (например, фоновой задачей Worker'а каждые N минут).
        *   **Кэширование:** Активно использовать кэширование (Redis/Memcached) для снижения нагрузки на источник и БД.
        *   **Обработка ошибок источника/обновления:** При невозможности обновить курс, использовать последнее актуальное значение из кэша/БД. Если актуального значения нет (старое или отсутствует), необходимо вернуть ошибку (`ConfigurationError` или аналогичную), чтобы предотвратить операции по некорректному курсу. Логировать такие ситуации и отправлять оповещения.
    *   **Кэширование (Общее):** Реализовать кэширование и для других часто запрашиваемых справочных данных (банки, методы оплаты) для снижения нагрузки на БД (использовать Redis, Memcached или кэш в памяти с TTL).
    *   **Обработка ошибок (Общее):** Если данные не найдены в справочнике (например, неверный ID), возвращать `None` или выбрасывать специфическое исключение. Логировать такие случаи.

### 2.7. Утилиты Обработки Ошибок и Оповещений (`services.error_handler` или `utils.notifications`)

*   **Назначение:** Централизованная обработка и классификация ошибок, отправка оповещений.
*   **Компоненты:**
    *   **Кастомные классы исключений:** Определить иерархию исключений для бизнес-логики (например, `RequisiteNotFound`, `LimitExceeded`, `InsufficientBalance`, `ConfigurationError`).
    *   **Централизованный логгер ошибок:** Конфигурируется в `config.logger`.
    *   **Интеграция с системой мониторинга/оповещений:** Отправка критических ошибок (например, сбои Worker'а, ошибки транзакций, большое кол-во заявок в статусе 'failed') в Sentry, Prometheus/Alertmanager, PagerDuty и т.д.
    *   `report_critical_error(exception, context)`: Функция для отправки отчета об ошибке во внешние системы.

---

## 8. Механизм Подтверждения Статуса Ордера

**Назначение:** Обеспечение корректного завершения жизненного цикла ордера (`order_history`) после его назначения трейдеру, включая обработку подтверждений от трейдера и клиента (для PayIn), расчет комиссий и обновление балансов. Этот механизм является критически важным для консистентности финансовых данных.

**Компоненты и Функционал:**

1.  **API Эндпоинты для Статусов Ордера (в соответствующих `api_routers`):**
    *   **Для Трейдера (`/api/trader/orders/{order_id}/confirm`, `/api/trader/orders/{order_id}/cancel` и т.д.):**
        *   Позволяет трейдеру подтвердить успешное выполнение (прикрепив чек для PayOut) или отменить/оспорить ордер.
        *   Должны проверять, что ордер назначен именно этому трейдеру и находится в соответствующем статусе (например, 'assigned').
        *   Требуют загрузки подтверждающих документов (чек для PayOut).
    *   **Для Клиента PayIn (через API мерчанта):**
        *   Эндпоинт для клиента (вызываемый через фронтенд мерчанта или API мерчанта) для подтверждения совершения оплаты и загрузки чека/скриншота.
        *   Изменяет статус `OrderHistory` на 'pending_trader_confirmation' (или аналогичный), делая ордер видимым для подтверждения трейдером.
    *   **Для Администратора/Саппорта:** Эндпоинты для ручного изменения статуса ордера в спорных ситуациях.

2.  **Сервис Управления Статусами Ордера (`services.order_status_manager`):**
    *   **Описание:** Инкапсулирует логику перехода `OrderHistory` между статусами (`assigned` -> `pending_trader_confirmation` (PayIn) -> `completed` / `failed` / `cancelled` / `dispute`).
    *   **Основные функции:**
        *   `confirm_payment_by_client(order_id: int, proof_document_url: str, db_session: Session)`: Вызывается из API мерчанта. Обновляет статус на 'pending_trader_confirmation', сохраняет ссылку на документ.
        *   `confirm_order_by_trader(order_id: int, trader_id: int, proof_document_url: Optional[str], db_session: Session)`: Вызывается из API трейдера.
            *   Проверяет права трейдера и текущий статус ордера.
            *   Обновляет статус на `completed`.
            *   **Важно:** *После* успешного COMMIT этой транзакции, инициирует вызов `services.balance_manager.update_balances_for_completed_order(order_id)` (например, через фоновую задачу или прямой вызов, если он быстрый и надежный).
        *   `cancel_order(order_id: int, user_id: int, role: str, reason: str, db_session: Session)`: Обрабатывает отмену ордера, возможно, с возвратом замороженных средств (требует доп. логики в `balance_manager`).
        *   `dispute_order(...)`: Обработка спорных ситуаций.
    *   **Транзакционность:** Все операции по изменению статуса должны выполняться в рамках атомарных транзакций (`database.utils.atomic_transaction`).
    *   **Заморозка/Разморозка Балансов:**
        *   **При назначении ордера (`order_processor`):** Происходит *неявная* заморозка за счет проверки лимитов. Для PayOut может потребоваться *явная* проверка и возможно блокировка части крипто-баланса трейдера (сложнее реализовать). **Уточнение:** Ваше описание указывает, что заморозка/списание происходит *после* подтверждения. Это упрощает логику при назначении. Расчеты и списания/начисления происходят только при переходе в `completed`.
        *   **При отмене/провале:** Если была явная заморозка, требуется логика разморозки.

3.  **Фоновый процесс для Таймаутов (Опционально):**
    *   **Описание:** Worker может отслеживать ордера, "зависшие" в промежуточных статусах дольше установленного времени (`processing_ttl` из `MerchantStore` или глобальный).
    *   **Действие:** Может автоматически переводить ордер в статус 'failed' или 'requires_attention' и отправлять уведомление.

**Взаимодействие:**

*   API роутеры вызывают функции `services.order_status_manager`.
*   `order_status_manager` использует `database.utils` для работы с БД и `balance_manager` (опосредованно, после подтверждения) для обновления балансов.
*   Worker может взаимодействовать с `order_status_manager` для обработки таймаутов.

**Математика и Курсы:**

*   Момент фиксации курса для расчета сумм и комиссий критичен. Вероятно, он должен фиксироваться при создании `OrderHistory` в `order_processor` и сохраняться в `OrderHistory`.
*   Все расчеты комиссий и обновления балансов в `balance_manager` должны использовать **зафиксированный курс** из `OrderHistory`.

---

## 9. Аудит Лог (`services.audit_logger`)

**Назначение:** Обеспечение отслеживаемости и подотчетности действий пользователей и системы путем записи ключевых событий в специальный лог.

**Компоненты и Функционал:**

1.  **Модель `AuditLog` (в `db.py`):** Определяет структуру записи аудита (см. `README_DB.md`).
2.  **Сервис `AuditLogger`:**
    *   **Описание:** Предоставляет простой интерфейс для записи событий аудита из различных частей системы.
    *   **Основная функция:** `log_action(action: str, user_id: Optional[int], user_role: Optional[str], target_entity: Optional[str] = None, target_id: Optional[int] = None, details: Optional[dict] = None, ip_address: Optional[str] = None, db_session: Session)`.
    *   **Реализация:**
        *   Принимает необходимые параметры.
        *   Создает объект `AuditLog`.
        *   Добавляет его в **текущую сессию БД** `db_session`. Запись аудита должна быть частью той же транзакции, что и основное действие, чтобы гарантировать, что аудит записывается только при успешном выполнении действия.
        *   Не должна прерывать основное выполнение при ошибке записи аудита (но должна логировать саму ошибку записи аудита).
3.  **Интеграция:**
    *   Функция `log_action` должна вызываться из всех критически важных мест системы:
        *   После успешного логина/выхода.
        *   При изменении статусов/данных магазинов, реквизитов, пользователей.
        *   При подтверждении/отмене ордеров.
        *   При ручных операциях администраторов.
        *   При важных системных событиях (например, сбой обработки ордера).
    *   Для получения `user_id`, `user_role`, `ip_address` можно использовать зависимости FastAPI (`Depends(get_current_user)`, `Request`).

**Цель:** Предоставить возможность расследования инцидентов, мониторинга активности пользователей и подтверждения выполнения операций.

---

## 10. Сервис Обнаружения Мошенничества (`services.fraud_detector`)

**Назначение:** Снижение рисков мошеннических операций путем анализа транзакций и активности пользователей на основе предопределенных правил и паттернов.

**Компоненты и Функционал:**

1.  **Хранилище Правил и Порогов:**
    *   Конфигурация порогов (например, макс. сумма/количество транзакций в час/день для пользователя/IP/реквизита/client_id).
    *   Возможность ведения списков (черные/белые списки IP, реквизитов, пользователей).
    *   Может храниться в конфигурации, отдельной таблице БД или Redis.

2.  **Сервис `FraudDetectionService`:**
    *   **Основные функции:**
        *   `check_incoming_order(order: IncomingOrder, db_session: Session) -> FraudCheckResult`:
            *   Вызывается из `order_processor` *перед* подбором реквизита.
            *   Проверяет ордер по velocity-лимитам (требует запросов к `order_history` или агрегирующим таблицам/счетчикам).
            *   Проверяет наличие участников (IP, client_id, возможно, реквизиты) в черных/белых списках.
            *   Возвращает результат: `ALLOW`, `DENY`, `REQUIRE_MANUAL_REVIEW`.
        *   `check_order_confirmation(...) -> FraudCheckResult`:
            *   Может вызываться из `order_status_manager` при подтверждении.
            *   Проверяет на подозрительные паттерны подтверждения.
    *   **Хранение Счетчиков (Velocity):** Для эффективного подсчета частоты операций рекомендуется использовать Redis (с TTL) или специализированные таблицы/материализованные представления в БД.

3.  **Интеграция:**
    *   `order_processor` должен вызывать `check_incoming_order`. При результате `DENY` - ордер сразу переводится в `failed`. При `REQUIRE_MANUAL_REVIEW` - в специальный статус, требующий вмешательства админа/саппорта.
    *   Результаты проверок должны логироваться в `AuditLog`.
    *   Система оповещений (`utils.notifications`) должна информировать о срабатывании правил или необходимости ручной проверки.

**Цель:** Минимизация финансовых потерь от фрода, повышение доверия к системе.

---

## 11. Механизмы Защиты API и Ограничения Частоты Запросов (Rate Limiting)

**Назначение:** Обеспечение стабильности и безопасности API путем предотвращения злоупотреблений, защиты от простых ботов и атак на уровне приложения (Application-Level), а также гарантирования справедливого использования ресурсов. Эти механизмы **дополняют** внешнюю инфраструктурную защиту от DDoS (реализуемую через CDN/WAF).

**Компоненты и Функционал:**

1.  **Rate Limiter (Middleware/Decorator):**
    *   **Описание:** Ключевой компонент для ограничения количества запросов к API эндпоинтам за определенный промежуток времени.
    *   **Реализация:**
        *   Может быть реализован как **FastAPI Middleware**, применяемое глобально или к конкретным группам маршрутов (`APIRouter`).
        *   Или с использованием декораторов для отдельных эндпоинтов, требующих специфических лимитов.
        *   Рекомендуется использовать готовую библиотеку, например, `slowapi`, которая хорошо интегрируется с FastAPI и поддерживает различные хранилища для счетчиков (память, Redis).
    *   **Стратегии:**
        *   **По IP-адресу:** Базовый уровень защиты для неаутентифицированных или публичных эндпоинтов.
        *   **По пользователю/API-ключу:** Более точное ограничение для аутентифицированных пользователей или внешних интеграций (мерчантов). Позволяет устанавливать разные лимиты для разных категорий пользователей/клиентов.
    *   **Хранение состояния:** Для эффективной работы в распределенной среде (несколько экземпляров бэкенда) состояние лимитов (счетчики запросов) должно храниться во внешнем быстром хранилище, например, **Redis**.

2.  **Модуль Блокировки IP (Опционально, но рекомендовано):**
    *   **Описание:** Механизм для динамической блокировки IP-адресов, с которых наблюдается подозрительная активность (слишком много ошибок 4xx, попытки сканирования, срабатывание "honeypot"-ловушек).
    *   **Реализация:**
        *   Может быть интегрирован с Rate Limiter'ом или реализован как отдельное Middleware.
        *   Список заблокированных IP также должен храниться во внешнем хранилище (например, Redis с TTL) для согласованности между экземплярами бэкенда.
        *   Требует интеграции с логгером для фиксации причин блокировки.

3.  **Интеграция с WAF (если используется):**
    *   **Описание:** Если на уровне инфраструктуры используется Web Application Firewall (WAF), бэкенд может предоставлять ему дополнительную информацию или реагировать на его сигналы (например, через специфические заголовки, которые WAF добавляет к заблокированным или подозрительным запросам).

**Взаимодействие:**

*   Rate Limiter и модуль блокировки IP должны работать как Middleware, обрабатывая запрос *до* основной логики эндпоинта.
*   При превышении лимита или обнаружении заблокированного IP, Middleware должно немедленно возвращать соответствующий HTTP-ответ (например, `429 Too Many Requests` или `403 Forbidden`) и прерывать дальнейшую обработку запроса.

**Цель:** Снизить нагрузку на основные сервисы, предотвратить исчерпание ресурсов и защититься от простых автоматизированных атак, которые могут пройти через базовые фильтры DDoS-защиты.

---

Эта расширенная документация закладывает основу для построения действительно надежной и отказоустойчивой системы обработки платежей.

---

Эта документация представляет собой высокоуровневое описание необходимых утилит для реализации основной логики системы. Детальная реализация каждого модуля будет описана в соответствующих файлах исходного кода и, при необходимости, в отдельных README.

### 3.7. Утилиты Платежного Шлюза

*   **Назначение:** Обеспечение работы интерфейса для конечных клиентов магазинов.
*   **Компоненты:**
    *   **`Gateway Request Handler` (Сервис/Логика в API Роутере Шлюза):**
        *   Прием и валидация запросов от фронтенда шлюза (HPP/Виджет).
        *   Идентификация мерчанта и клиента магазина (`customer_id`).
        *   **Загрузка настроек магазина (`MerchantStore`) для идентификации мерчанта.**
        *   **Проверка параметров запроса (`customer_id`, `amount`) в соответствии с настройками магазина (`gateway_require_customer_id_param`, `gateway_require_amount_param`).** Если настройка требует параметр, а он отсутствует - возврат ошибки.
        *   Вызов `Order Service` для создания `IncomingOrder` с нужными параметрами (`amount`, `payment_method`, `customer_id`, `return_url`, `callback_url`).
        *   Получение статуса ордера и данных реквизита для отображения клиенту.
        *   Обработка запросов подтверждения оплаты от клиента (с загрузкой чека в S3 через `utils.s3_client` и вызовом `Order Status Manager`).
        *   Формирование ответов для фронтенда шлюза.
    *   **`Merchant Callback Service` (Сервис/Утилита):**
        *   Формирование данных для коллбэка (статус ордера, ID ордера, ID клиента, сумма и т.д.).
        *   **Подпись данных коллбэка:** Использование секрета мерчанта (`MerchantStore.secret_key`) для генерации подписи (например, HMAC-SHA256 от тела запроса + секрет).
        *   Отправка POST-запроса на `callback_url` мерчанта с данными и заголовком подписи (например, `X-Signature`).
        *   Реализация механизма повторных отправок (retry) в случае неудачи доставки коллбэка (возможно, с использованием фоновой задачи).
        *   Логирование отправки и результатов коллбэков.
    *   **`(Опционально) Gateway Session Manager`:**
        *   Управление временными сессиями для клиентов на шлюзе, если флоу требует сохранения состояния между шагами (например, хранение ID созданного ордера до момента загрузки чека).
        *   Может использовать Redis или другой механизм кэширования.

### 3.8. Сервис Обменных Курсов

*   **Назначение:** Предоставление актуальных обменных курсов между валютами.
*   **Компоненты:**
    *   Реализовать функции для получения деталей платежных методов, банков и т.д.
    *   Применить кэширование (in-memory или Redis) для часто запрашиваемых данных.
    *   Обработка ошибок при взаимодействии с БД или кэшем. 