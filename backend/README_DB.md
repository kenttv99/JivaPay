# Документация по Базе Данных JivaPay

## 1. Общее Описание

Эта база данных предназначена для хранения информации, необходимой для работы платежной системы JivaPay. Она включает данные о пользователях (мерчантах и трейдерах), их магазинах и реквизитах, историю финансовых операций (ордеров), входящие заявки, балансы, настройки и справочную информацию.

Структура разработана для поддержки основной логики системы:
*   **Прием входящих заявок:** Немедленная фиксация запросов на PayIn / PayOut от магазинов мерчантов.
*   **Асинхронная обработка:** Поиск и назначение подходящих реквизитов трейдеров для выполнения заявок из очереди.
*   **Выполнение ордеров:** Отслеживание статуса ордеров после назначения реквизита.
*   **Учет:** Отслеживание балансов и истории операций для всех участников.
*   **Управление:** Настройка лимитов, комиссий и доступов.

## 2. Основные Сущности (Таблицы)

### 2.1. Мерчанты (`merchants`, `merchant_stores`)
*   `merchants`: Хранит основную информацию об аккаунтах мерчантов (логин, пароль, 2FA, статус доступа).
*   `merchant_stores`: Хранит информацию о магазинах, созданных мерчантами.
    *   **Ключевые поля:**
        *   `merchant_id`: Связь с владельцем-мерчантом.
        *   `store_name`: Название магазина.
        *   `crypto_currency_id`: Основная *криптовалюта* для баланса и работы магазина.
        *   `fiat_currency_id`: Основное *фиатное* направление работы магазина.
        *   `balance`: Текущий *крипто*-баланс магазина (DECIMAL 20, 8).
        *   `lower_limit`, `upper_limit`: Лимиты (мин/макс) для суммы ордеров *в фиатной валюте* (DECIMAL 20, 2).
        *   `public_api_key`, `private_api_key`: API ключи магазина (Внимание: `private_api_key` требует безопасного хранения/хеширования в приложении).
        *   `pay_in_enabled`, `pay_out_enabled`: Флаги, разрешающие прием (PayIn) или выплаты (PayOut) для всего магазина.
        *   `access`, `trafic_access`: Флаги доступа.

### 2.2. Трейдеры (`traders`, `req_traders`, `full_requisites_settings`, `owner_of_requisites`)
*   `traders`: Хранит информацию об аккаунтах трейдеров.
    *   **Ключевые поля:**
        *   `email`, `password_hash`, `avatar_url`, `two_factor_auth_token`: Данные аккаунта.
        *   `preferred_fiat_currency_id`: Основная *фиатная* валюта, с которой работает трейдер.
        *   `crypto_currency_id`: Основная *криптовалюта*, с которой работает трейдер (может быть `NULL` или использоваться для будущих расширений).
        *   `verification_level`: Уровень верификации.
        *   `pay_in`, `pay_out`: Глобальные флаги разрешения работы трейдера на прием/выплату.
        *   `in_work`: Основной флаг активности трейдера.
        *   `trafic_priority`: Приоритет трейдера при подборе реквизита (1 - наивысший, 10 - низший, стандартно 5).
        *   `access`: Флаг доступа к аккаунту.
        *   `time_zone_id`: Часовой пояс трейдера (важно для сброса дневных лимитов).
    *   **Индексы:** В дополнение к стандартным, есть индекс `ix_trader_priority_lookup` по (`in_work`, `trafic_priority`) для ускорения подбора реквизитов.
*   `owner_of_requisites`: Определяет "владельца" (группу) реквизитов (ФИО).
*   `req_traders`: Хранит информацию о конкретных реквизитах (карта, счет и т.д.), добавленных трейдером.
    *   **Ключевые поля:** `trader_id`, `owner_of_requisites_id`, `fiat_id`, `method_id`, `bank_id`, `req_number` (требует защиты), `status`.
*   `full_requisites_settings`: Хранит детальные настройки для *каждого* реквизита (`requisite_id`).
    *   **Ключевые поля:** `pay_in`, `pay_out` (флаги), `lower_limit`, `upper_limit`, `total_limit`, `turnover_day_max`, `turnover_limit_minutes`.

### 2.3. Входящие Заявки (`incoming_orders`)
*   **Назначение:** Фиксирует *каждый* запрос на PayIn/PayOut от мерчанта **немедленно** после его поступления. Служит очередью для асинхронной обработки и подбора реквизитов.
*   **Ключевые поля:**
    *   `id`: Уникальный ID входящей заявки.
    *   `merchant_id`, `store_id`: Источник заявки.
    *   `gateway_id`: Шлюз магазина, через который пришла заявка (если применимо).
    *   `target_method_id`, `target_bank_id`: Опциональные предпочтения мерчанта.
    *   `fiat_currency_id`, `crypto_currency_id`: Валюты операции.
    *   `total_fiat`, `amount_currency`: Суммы операции.
    *   `exchange_rate`: Курс обмена, зафиксированный в момент создания заявки.
    *   `store_commission`: Сумма комиссии магазина, рассчитанная в момент создания заявки.
    *   `order_type`: Тип ('pay_in', 'pay_out').
    *   `status`: Текущий статус заявки в очереди ('new', 'processing', 'assigned', 'failed', 'retrying').
    *   `retry_count`, `last_attempt_at`, `failure_reason`: Данные для управления обработкой.
    *   `created_at`, `updated_at`: Временные метки.
    *   `assigned_order`: Связь (один-к-одному) с созданным ордером в `order_history`.

### 2.4. История Ордеров (`order_history`)
*   **Назначение:** Фиксирует ордера, которым **уже был успешно назначен** реквизит трейдера. Содержит полную информацию о выполненной или выполняемой операции.
*   **Ключевые поля:**
    *   `id`: Уникальный ID выполненного ордера.
    *   `incoming_order_id`: Ссылка на исходную заявку в `incoming_orders`.
    *   `hash_id`: Уникальный публичный идентификатор ордера.
    *   `trader_id`, `requisite_id`: **Важно:** Трейдер и реквизит, назначенные для выполнения (NOT NULL).
    *   `merchant_id`, `store_id`, `gateway_id`: Участники со стороны мерчанта.
    *   `method_id`, `bank_id`, `crypto_currency_id`, `fiat_id`: Детали операции.
    *   `order_type`: Тип ордера ('pay_in', 'pay_out').
    *   `exchange_rate`: Курс обмена (копируется из `incoming_orders` или может быть переопределен).
    *   `amount_currency`, `total_fiat`: Суммы.
    *   `store_commission`: Комиссия магазина (копируется из `incoming_orders`).
    *   `trader_commission`: Комиссия трейдера (рассчитывается при назначении).
    *   `status`: Статус *выполнения* ордера ('pending', 'processing', 'completed', 'failed', 'cancelled' и т.д.) - **после** назначения реквизита.
    *   `created_at`, `updated_at`: Временные метки.

### 2.5. Балансы и История Балансов (`balance_stores`, `balance_store_history`, `balance_traders`, `balance_trader_fiat_history`, `balance_trader_crypto_history`)
*   `balance_stores`: Текущий *крипто*-баланс магазина.
*   `balance_store_history`: История изменений *крипто*-баланса магазинов.
*   `balance_traders`: Текущий *фиат*-баланс трейдера.
*   `balance_trader_fiat_history`: История изменений *фиат*-баланса трейдеров.
*   `balance_trader_crypto_history`: История изменений *крипто*-баланса трейдеров.

### 2.6. Справочники (`banks`, `payment_methods`, `fiat_currencies`, `crypto_currencies`, `countries`, `time_zones`, `exchange_rates`, `avalible_bank_methods`)
*   Хранят справочную информацию.

### 2.7. Администраторы и Поддержка (`admins`, `supports`)
*   Данные для доступа к внутренним панелям.

## 3. Логика Обработки Заявок и Подбора Реквизита

Процесс разделен на два этапа:

**Этап 1: Прием Заявки (Синхронный)**
1.  Мерчант через магазин инициирует запрос на PayIn/PayOut.
2.  Приложение **немедленно** создает запись в таблице `incoming_orders` со статусом `'new'`, сохраняя все детали запроса.
3.  Мерчанту возвращается подтверждение приема заявки (например, ID из `incoming_orders`).

**Этап 2: Подбор Реквизита и Создание Ордера (Асинхронный)**
1.  **Фоновый обработчик (Worker)** периодически или по сигналу запрашивает заявки из `incoming_orders` со статусом `'new'` или `'retrying'`.
2.  Для каждой заявки Worker **начинает транзакцию БД** (с уровнем изоляции `REPEATABLE READ` или `SERIALIZABLE`).
3.  Внутри транзакции Worker выполняет **поиск кандидата:** SQL-запрос (`SELECT ... FOR UPDATE SKIP LOCKED`), который:
    *   Объединяет `req_traders`, `traders`, `full_requisites_settings`.
    *   Фильтрует по параметрам заявки (`fiat_id`, `method_id`, `bank_id`).
    *   Проверяет статические условия: `Trader.in_work = TRUE`, `ReqTrader.status = 'approve'`, флаги `pay_in`/`pay_out` в `FullRequisitesSettings`, статические лимиты (`lower_limit`, `upper_limit`).
    *   **Сортирует** кандидатов по `Trader.trafic_priority` (ASC) и другим критериям.
    *   Выбирает **одного** лучшего кандидата (`LIMIT 1`).
    *   **Блокирует** строку кандидата (`FOR UPDATE SKIP LOCKED`).
4.  **Проверка динамических лимитов:** Если кандидат найден и заблокирован:
    *   Рассчитывается текущий дневной/общий оборот кандидата по данным из `order_history`.
    *   Проверяется, не превысят ли лимиты (`turnover_day_max`, `total_limit`) из `FullRequisitesSettings` с учетом суммы текущей заявки.
5.  **Принятие решения:**
    *   **Успех:** Если все проверки пройдены, Worker:
        1.  Создает новую запись в `order_history`, копируя данные из `incoming_orders` и добавляя `requisite_id`, `trader_id`.
        2.  Обновляет запись в `incoming_orders`, устанавливая `status='assigned'` и связывая ее с созданным `order_history.id`.
        3.  Коммитит транзакцию.
    *   **Неудача (Нет кандидата / Лимит):** Если кандидат не найден или не прошел динамическую проверку:
        1.  Worker обновляет запись в `incoming_orders` (увеличивает `retry_count`, ставит `last_attempt_at`, возможно, меняет статус на `retrying`/`failed`, записывает причину).
        2.  Откатывает транзакцию (или ее часть, если кандидат был найден, но не подошел).

Этот двухэтапный подход с асинхронной обработкой гарантирует, что ни одна заявка не теряется, система может обрабатывать очередь, а подбор реквизита происходит с максимальной надежностью проверки лимитов.

## 4. Соглашения и Принципы

*   **Именование:** snake_case.
*   **Время:** `TIMESTAMP(timezone=True)`, UTC.
*   **Точность:** DECIMAL(20, 8) крипто, DECIMAL(20, 2) фиат.
*   **Каскадное удаление:** Осторожно, в основном для несамостоятельных сущностей.
*   **Индексы:** Созданы для PK, FK, часто фильтруемых/сортируемых полей, а также специализированные индексы (`ix_trader_priority_lookup`, `ix_incoming_orders_status_created`, `ix_incoming_orders_merchant_store`) для оптимизации ключевых запросов.
*   **Безопасность:** Чувствительные данные требуют защиты на уровне приложения.

Эта документация описывает текущее состояние. При внесении изменений в структуру или логику базы данных, пожалуйста, обновляйте этот файл.

