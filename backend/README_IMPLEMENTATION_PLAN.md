# План Реализации Утилит Backend

---

## 1. Введение

Этот документ описывает пошаговый план реализации бэкенд-утилит для платежной системы JivaPay, как детализировано в `README_UTILITIES.md`. План основан на текущей архитектуре проекта и существующих документах.

**Цель:** Систематическая разработка необходимых модулей и функций для обеспечения надежной, отказоустойчивой и эффективной работы основной логики системы.

---

## 2. Предварительные шаги

1.  **Создание директорий:** Создать новые директории в `backend/`: `services/`, `utils/`, `worker/` (если еще не существуют). Убедиться, что в каждой новой директории есть файл `__init__.py`.
2.  **Конфигурация:** Определить и добавить необходимые новые переменные окружения (или настройки в конфигурационном файле, например, `.env`) для параметров утилит (например, `MAX_ORDER_RETRIES`, `RETRY_BACKOFF_FACTOR`, настройки кэша Redis, параметры подключения к брокеру сообщений, URL Sentry/другой системы мониторинга).
    *   **Управление Секретами:** Для **production** окружения настоятельно рекомендуется использовать специализированные системы управления секретами (например, HashiCorp Vault, AWS/GCP/Azure Secrets Manager, K8s Secrets) вместо `.env` файлов для хранения чувствительных данных (пароли БД, JWT Secret, ключи API и т.д.).

---

## 3. План Реализации по Модулям

### 3.1. Базовые Утилиты и Исключения

*   **Файл:** `backend/utils/exceptions.py`
    *   **Задача:** Определить иерархию кастомных исключений.
    *   **Шаги:**
        *   Создать базовый класс `JivaPayException(Exception)`.
        *   Создать специфичные исключения, наследуемые от `JivaPayException` или стандартных исключений: `RequisiteNotFound`, `LimitExceeded`, `InsufficientBalance`, `ConfigurationError`, `OrderProcessingError`, `DatabaseError`, `NotificationError`, `CacheError` и т.д.

*   **Файл:** `backend/database/utils.py`
    *   **Задача:** Реализовать утилиты для безопасной работы с БД.
    *   **Шаги:**
        *   Реализовать `get_db_session()` как менеджер контекста (`@contextlib.contextmanager`), используя **существующий `SessionLocal` из `backend.database.engine`**, с `try...finally` для `db.close()`.
        *   Реализовать `atomic_transaction()` как декоратор или менеджер контекста, использующий `db_session.begin()` или `try...except...else` с `db.commit()` и `db.rollback()`. Добавить логирование начала/конца/ошибки транзакции.
        *   Реализовать базовые CRUD-функции (например, `create_object`, `get_object_or_none`, `update_object_db`) с логированием и обработкой стандартных исключений SQLAlchemy (`IntegrityError`, `NoResultFound`), возможно, пробрасывая кастомные исключения из `backend.utils.exceptions`.

*   **Файл:** `backend/utils/notifications.py`
    *   **Задача:** Настроить отправку оповещений о критических ошибках.
    *   **Шаги:**
        *   Интегрировать выбранную библиотеку для отправки отчетов (например, Sentry SDK).
        *   Инициализировать SDK с DSN из конфигурации.
        *   Реализовать функцию `report_critical_error(exception, context_message="", **kwargs)` для отправки исключений и дополнительного контекста в систему мониторинга.
        *   Добавить обработку ошибок при отправке оповещений (логировать, но не прерывать основной поток).

### 3.2. Middleware: Ограничение Частоты Запросов (Rate Limiting)

*   **Файлы:** `backend/middleware/rate_limiting.py`, `backend/main.py` (для подключения Middleware).
    *   **Задача:** Реализовать защиту API от злоупотреблений и простых ботов.
    *   **Шаги:**
        *   Добавить зависимость `slowapi` в `requirements.txt`.
        *   Добавить зависимость Redis (`redis[hiredis]`) если еще не добавлена.
        *   Настроить подключение к Redis (например, через `config`).
        *   В `rate_limiting.py`:
            *   Импортировать `Limiter`, `Request`.
            *   Инициализировать `Limiter` с использованием `RedisStorage` (`Limiter(key_func=get_remote_address, storage_uri=REDIS_URL)`). Можно определить разные key_func для разных стратегий (IP, user). 
            *   Определить обработчик для исключения `RateLimitExceeded` (`@app.exception_handler(RateLimitExceeded)`), который будет возвращать HTTP 429.
        *   В `backend/main.py`:
            *   Импортировать `Limiter`, `RateLimitExceeded` и созданный обработчик исключения.
            *   Добавить Middleware: `app.add_middleware(SlowAPIMiddleware)`.
            *   Добавить обработчик исключения.
        *   Применить ограничения к маршрутам:
            *   Глобально (через `default_limits` в `Limiter`).
            *   Или к конкретным `APIRouter` или эндпоинтам с использованием `limiter.limit("...")` в качестве зависимости (`Depends`) или декоратора.
        *   Реализовать различные стратегии лимитирования (по IP, по пользователю/API-ключу) при необходимости, используя разные `key_func`.
        *   Настроить конфигурацию лимитов (например, "100/minute", "10/second") через переменные окружения.
        *   (Опционально) Реализовать в этом же Middleware или отдельном логику блокировки IP на основе частых ошибок или порогов Rate Limiter'а, сохраняя список блокировки в Redis.

### 3.3. Сервисы Бизнес-Логики

*   **Файл:** `backend/services/reference_data.py`
    *   **Задача:** Реализовать доступ к справочным данным с кэшированием.
    *   **Шаги:**
        *   Настроить клиент кэша (например, Redis) или использовать библиотеку для in-memory кэша (например, `cachetools`).
        *   Реализовать функции `get_exchange_rate(crypto_id, fiat_id)`, `get_bank_details(bank_id)`, `get_payment_method_details(method_id)` и т.д.
        *   Внутри функций реализовать логику: сначала проверка кэша, при промахе – запрос к БД (используя `database.utils`), запись результата в кэш, возврат результата.
        *   Добавить обработку ошибок БД и кэша (пробрасывать `CacheError`, `DatabaseError` из `backend.utils.exceptions`), логирование. Решить, возвращать ли `None` или пробрасывать исключение при отсутствии данных.

*   **Файл:** `backend/services/requisite_selector.py`
    *   **Задача:** Реализовать логику подбора реквизита.
    *   **Шаги:**
        *   Реализовать основную функцию `find_suitable_requisite(incoming_order: IncomingOrder, db_session: Session) -> Tuple[Optional[int], Optional[int]] | None` (возвращает `(requisite_id, trader_id)` или `None`, или выбрасывает исключение).
        *   Сформировать и выполнить оптимизированный SQL-запрос SQLAlchemy с JOIN'ами (`req_traders`, `traders`, `full_requisites_settings`), фильтрами по параметрам заявки, статусам, статическим лимитам.
        *   Применить сортировку по `Trader.trafic_priority` (ASC), затем по `ReqTrader.last_used_at` (ASC, NULLS FIRST) для реализации round-robin.
        *   Использовать `with_for_update(skip_locked=True)`. `limit(1)`.
        *   После назначения заявки выбранному реквизиту обновить поле `last_used_at` на текущее время.
        *   Обработать случай `NoResultFound` или пустой результат -> вернуть `None` (или пробросить `RequisiteNotFound`).
        *   Если кандидат найден: выполнить запросы для проверки динамических лимитов (агрегация по `order_history` в той же сессии).
        *   Если лимит превышен -> вернуть `None` (или пробросить `LimitExceeded`).
        *   Если все ОК -> вернуть `(requisite.id, trader.id)`.
        *   Добавить подробное логирование всех шагов и причин неудач.
        *   Перехватывать ошибки БД, логировать и пробрасывать `DatabaseError` из `backend.utils.exceptions`.

*   **Файл:** `backend/services/balance_manager.py`
    *   **Задача:** Реализовать расчет комиссий и обновление балансов.
    *   **Шаги:**
        *   Реализовать `calculate_commissions(order: OrderHistory, store: MerchantStore, trader: Trader, db_session: Session) -> Tuple[Decimal, Decimal]` (возвращает store_commission, trader_commission). Загрузить настройки `StoreCommission`, `TraderCommission`.
        *   Обработать отсутствие настроек (логировать, использовать default или пробросить `ConfigurationError` из `backend.utils.exceptions`).
        *   Реализовать `update_balances_for_completed_order(order_id: int, db_session: Session)`:
            *   Загрузить `OrderHistory`, `MerchantStore`, `Trader`.
            *   Загрузить и **заблокировать** (`with_for_update`) соответствующие строки `BalanceStore`, `BalanceTrader`.
            *   Выполнить дебетование/кредитование балансов.
            *   Создать записи в `BalanceStoreHistory`, `BalanceTraderFiatHistory`, `BalanceTraderCryptoHistory`.
            *   Обработать возможные ошибки (например, пробросить `InsufficientBalance` из `backend.utils.exceptions`), логировать, пробрасывать исключения.

*   **Файл:** `backend/services/order_processor.py`
    *   **Задача:** Реализовать оркестрацию обработки входящей заявки.
    *   **Шаги:**
        *   Реализовать основную функцию `process_incoming_order(incoming_order_id: int)`.
        *   **Добавить проверку идемпотентности** (проверить статус `IncomingOrder` или наличие `OrderHistory` для `incoming_order_id`) *перед* основной транзакцией.
        *   Использовать `database.utils.get_db_session` и `atomic_transaction` для **основной** логики.
        *   Внутри основной транзакции: загрузить `IncomingOrder` по `id` с `with_for_update`. Проверить статус (`'new'`, `'retrying'`).
        *   **Вызвать `fraud_detector.check_incoming_order(...)`** и обработать результат (`DENY`/`REQUIRE_MANUAL_REVIEW` -> переход к обновлению статуса).
        *   Вызвать `requisite_selector.find_suitable_requisite`.
        *   **Обработка результата:**
            *   **Успех (реквизит найден):**
                *   Вызвать `balance_manager.calculate_commissions` (только для расчета, не для записи истории).
                *   Создать объект `OrderHistory`, заполнить поля из `IncomingOrder`, добавить `requisite_id`, `trader_id`, `trader_commission`, **зафиксированный курс**.
                *   Добавить `OrderHistory` в сессию.
                *   Обновить `IncomingOrder` (`status='assigned'`, `assigned_order=order_history_obj`, `failure_reason=None`).
                *   Логировать успех.
                *   (Основная транзакция успешно коммитится декоратором/менеджером `atomic_transaction`)
            *   **Неудача (кандидат не найден / лимит / фрод) или Исключение:**
                *   (Основная транзакция откатывается декоратором/менеджером `atomic_transaction` при выходе из блока `try` по исключению или без явного `return`/`break`).
                *   В блоке `except` (или `finally`, если используется `try...finally` вокруг основной логики):
                    *   Определить причину неудачи/исключение.
                    *   **Выполнить обновление статуса `IncomingOrder` в отдельной транзакции:**
                        *   Использовать `database.utils.get_db_session` и `atomic_transaction` **повторно**.
                        *   Загрузить `IncomingOrder` (без блокировки).
                        *   Обновить поля (`retry_count`, `last_attempt_at`, `failure_reason`, статус `'retrying'` или `'failed'`).
                        *   Закоммитить **эту** транзакцию.
                        *   Логировать результат обновления статуса (успех/ошибка).
                    *   Логировать основную причину неудачи/исключение.
                    *   Вызвать `utils.notifications.report_critical_error`, если ошибка критическая.
                    *   (Если использовался `try...except`, то после обработки исключения можно его пробросить дальше `raise`, если это необходимо для логики вызывающего кода, например, Worker'а).

### 3.4. Фоновый Обработчик (Worker)

*   **Файлы:** `backend/worker/app.py` (настройка Celery/Dramatiq), `backend/worker/tasks.py` (определение задач), `backend/worker/scheduler.py` (или логика запуска/планирования задач, если не используется встроенный планировщик). Может потребоваться `requirements_worker.txt`.
    *   **Задача:** Реализовать систему фоновой обработки заявок.
    *   **Зависимости Worker'а (примерные):** `celery`/`dramatiq`, `redis`/`kombu` (брокер), `sqlalchemy`, `psycopg2-binary`/`asyncpg` (драйвер БД), `python-dotenv`, основные модели и утилиты проекта (`backend.database`, `backend.services`, `backend.utils`).
    *   **Шаги:**
        *   Выбрать и настроить брокер сообщений (Redis, RabbitMQ) и бэкенд результатов (если нужен).
        *   Настроить приложение Celery/Dramatiq (`app.py`), указать брокер, бэкенд, пути к задачам.
        *   В `tasks.py` определить задачу (например, `process_order_task`), которая принимает `incoming_order_id` и вызывает `services.order_processor.process_incoming_order`.
        *   Настроить параметры задачи: `autoretry_for` (указать перехватываемые исключения из `utils.exceptions`, например `DatabaseError`, `CacheError`), `retry_backoff`, `max_retries` (согласовать с `MAX_ORDER_RETRIES`), возможно, `acks_late=True`.
        *   (Опционально, если нужно обновление балансов через Worker) Определить задачу `update_balances_task`, вызывающую `services.balance_manager.update_balances_for_completed_order`.
        *   Реализовать логику периодического запуска (scheduler): (`scheduler.py` или Celery Beat / Dramatiq cron)
            *   Запрос к `IncomingOrder` для выборки ID заявок со статусом `'new'` или `'retrying'` (с учетом `last_attempt_at` и `retry_count` для backoff).
            *   Отправка выбранных ID в очередь задач (`process_order_task.delay(order_id)`).
            *   Добавить обработку ошибок на уровне шедулера (логирование, оповещения через `utils.notifications`).
        *   Настроить запуск Worker'ов и Scheduler'а (например, через systemd или Docker Compose).
        *   Настроить мониторинг очередей и Worker'ов (Flower для Celery, или через метрики Prometheus).

### 3.5. Сервис и API для Управления Статусами Ордера

*   **Файлы:** `backend/services/order_status_manager.py`, `backend/api_routers/trader.py`, `backend/api_routers/merchant.py` (или специфичный API для клиента магазина), `backend/api_routers/admin.py`.
    *   **Задача:** Реализовать логику подтверждения/отмены ордеров и соответствующие API эндпоинты.
    *   **Шаги:**
        *   В `order_status_manager.py` реализовать функции: `confirm_payment_by_client`, `confirm_order_by_trader`, `cancel_order`, `dispute_order` и т.д., используя `atomic_transaction`.
        *   Реализовать логику проверки прав доступа и корректности статусов перед изменением.
        *   Определить механизм запуска `balance_manager.update_balances_for_completed_order` после успешного подтверждения трейдером **(Рекомендация: отправка ID ордера в очередь задач Worker'а для асинхронного вызова `update_balances...` *после* успешного коммита транзакции изменения статуса. Это обеспечивает большую надежность).**
        *   В `api_routers/trader.py` добавить эндпоинты для `confirm_order_by_trader`, `cancel_order` (с обработкой загрузки чека для PayOut).
        *   В `api_routers/merchant.py` (или отдельном роутере) добавить эндпоинт для `confirm_payment_by_client` (с обработкой загрузки чека для PayIn).
        *   Добавить необходимые эндпоинты для админа/саппорта для управления статусами в нештатных ситуациях.
        *   Настроить сохранение ссылок на загруженные документы (подумать об использовании S3-совместимого хранилища).
        *   (Опционально) Реализовать в Worker'е задачу для отслеживания и обработки таймаутов ордеров.
        *   Добавить тесты для всех сценариев изменения статусов.

### 3.6. API Роутеры (`api_routers/`)

*   **Задача:** Реализовать HTTP интерфейсы для взаимодействия с системой.
*   **Файлы:** `backend/api_routers/merchant.py`, `trader.py`, `admin.py`, `support.py`.
*   **Шаги:**
    *   Создать роутеры для каждой роли.
    *   Определить Pydantic схемы (`schemas/`) для запросов и ответов.
    *   Реализовать эндпоинты для CRUD операций с основными сущностями (ордера, реквизиты, пользователи, магазины), используя соответствующие сервисы (`services/`).
    *   Добавить эндпоинты для специфичных действий (подтверждение ордера, создание заявки мерчантом и т.д.), вызывая `services.order_status_manager` и другие.
    *   **Защитить все эндпоинты (кроме, возможно, логина/регистрации) с помощью зависимостей аутентификации (`Depends(get_current_active_user)`).**
    *   Реализовать обработку ошибок на уровне API, возвращая корректные HTTP статусы и сообщения об ошибках (возможно, с использованием `utils.exceptions` и middleware).
    *   Настроить FastAPI для автоматической генерации OpenAPI документации.

### 3.7. API и Логика Платежного Шлюза

*   **Задача:** Реализовать интерфейс для конечных клиентов магазинов.
*   **Файлы:** `backend/api_routers/gateway.py` (новый), `backend/services/gateway_service.py` (новый, или логика в роутере), `backend/services/callback_service.py` (новый).
*   **Шаги:**
    *   **API Эндпоинты (`gateway.py`):**
        *   Определить эндпоинты для Pay-In: `/init` (прием данных, создание `IncomingOrder`), `/status/{order_id}` (получение статуса/реквизитов), `/confirm/{order_id}` (прием чека, подтверждение клиентом).
        *   Определить эндпоинты для Pay-Out: `/init` (прием данных, создание `IncomingOrder`), `/status/{order_id}` (получение статуса).
        *   Использовать Pydantic схемы для валидации данных.
        *   Продумать механизм идентификации мерчанта (например, через API ключ, передаваемый при инициации с сайта мерчанта, или по домену запроса).
        *   Эндпоинты, вероятно, будут публичными или использовать кратковременные токены сессии.
    *   **Логика Обработки (`gateway_service.py` или в `gateway.py`):**
        *   Реализовать логику `Gateway Request Handler`:
            *   Идентификация мерчанта (по API ключу из запроса или домену).
            *   **Загрузка `MerchantStore` для данного мерчанта.**
            *   **Валидация входных данных:** Проверить наличие `customer_id` и `amount` в параметрах запроса, если это требуется настройками `MerchantStore` (`gateway_require_..._param`). Вернуть ошибку 4xx, если обязательные параметры отсутствуют.
            *   Валидация остальных данных (метод оплаты, валюта и т.д.).
            *   Вызов `Order Service` для создания `IncomingOrder`.
            *   Обработка загрузки чеков (вызов `utils.s3_client`) и подтверждения оплаты клиентом (вызов `Order Status Manager`).
    *   **Сервис Коллбэков (`callback_service.py`):**
        *   Реализовать `Merchant Callback Service`: формирование данных, подпись с использованием `MerchantStore.secret_key`, отправка POST запроса на `callback_url`, логика повторов (retry).
        *   Интегрировать вызов этого сервиса после значимых изменений статуса ордера (например, в `Order Status Manager` или `Order Processor`).
    *   **Интеграция:**
        *   Убедиться, что `Order Service` принимает и сохраняет `customer_id`, `return_url`, `callback_url`.
        *   Обеспечить вызов `callback_service` в нужных точках изменения статуса ордера.
    *   **Тестирование:**
        *   Написать тесты для всего флоу шлюза (Pay-In, Pay-Out), включая обработку ошибок, загрузку чеков и отправку коллбэков.

---

## 4. Тестирование

*   Параллельно с разработкой каждого модуля писать юнит-тесты (с mock'ами зависимостей) и интеграционные тесты (с реальной тестовой БД).
*   Особое внимание уделить тестированию:
    *   Логики подбора реквизитов (`requisite_selector`) со всеми граничными условиями (лимиты, статусы, конкурентный доступ).
    *   Логики обработки ордеров (`order_processor`), включая обработку ошибок и обновление статусов.
    *   Транзакционности (`atomic_transaction`).
    *   Работы Worker'а (постановка задач, retry, backoff, обработка ошибок задачи).
    *   Обновления балансов.
    *   **Логики изменения статусов ордера (`order_status_manager`) и связанных API.**

---

## 5. Зависимости и Интеграция

*   Необходимо будет добавить новые зависимости (система очередей, кэширование, Sentry SDK, `python-dotenv`, **библиотека для работы с S3-хранилищем**, `slowapi`, `redis[hiredis]`, **`alembic`** и т.д.) в `requirements.txt` и, возможно, в `requirements_worker.txt`.
*   API Роутеры (`backend/api_routers`) должны будут использовать `database.utils` и `utils.exceptions` для создания записей `IncomingOrder` и обработки ошибок.
*   API Роутеры должны вызывать `services.order_status_manager` для изменения статусов ордеров.
*   Система подтверждения статуса ордера (`completed`/`failed`) должна будет вызывать `services.balance_manager.update_balances_for_completed_order` **(вероятно, асинхронно через Worker)**.

---

## 6. Предварительные шаги (Дополнения)

*   **Миграции БД (Alembic):** 
    *   Установить `alembic` (`pip install alembic`).
    *   Инициализировать Alembic в проекте (`alembic init alembic`).
    *   Настроить `alembic.ini` (указать `sqlalchemy.url`).
    *   Настроить `alembic/env.py` для корректного импорта метаданных ваших SQLAlchemy моделей (`target_metadata = Base.metadata`).
    *   Создать начальную миграцию (`alembic revision --autogenerate -m "Initial database schema"`).
    *   Применить миграцию (`alembic upgrade head`).
    *   В дальнейшем использовать `alembic revision --autogenerate` и `alembic upgrade head` для всех изменений схемы.
*   **Заполнение Данных (Seeding):** 
    *   Создать скрипты для заполнения начальных данных (например, в `alembic/versions/seeds/`).
    *   Можно использовать операции Alembic `op.bulk_insert` внутри отдельной ревизии (`alembic revision -m "Seed initial data"`) или создать кастомные команды `alembic`. 
    *   Заполнить необходимые справочники (валюты, роли, платежные системы) и создать пользователя-администратора по умолчанию.
*   **Аутентификация (JWT/OAuth2):** 
    *   Добавить зависимости: `python-jose[cryptography]`, `passlib[bcrypt]`.
    *   Создать файл `backend/security.py` (или аналогичный).
    *   В `security.py`:
        *   Определить настройки: `SECRET_KEY`, `ALGORITHM`, `ACCESS_TOKEN_EXPIRE_MINUTES` (из конфигурации).
        *   Реализовать функции: `create_access_token`, `verify_access_token`.
        *   Реализовать функцию `get_password_hash` (используя `passlib`). `verify_password` уже есть в `crypto.py`.
        *   Определить `OAuth2PasswordBearer` схему (`oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/merchant/auth/token")` - **URL нужно будет адаптировать для каждой роли!**).
        *   Реализовать функцию `get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db))`:
            *   Верифицирует токен.
            *   Извлекает ID пользователя из токена.
            *   Загружает пользователя из БД.
            *   Возвращает объект пользователя или выбрасывает `HTTPException` (401/403).
        *   Реализовать функцию `get_current_active_user` (проверяет `is_active` пользователя).
    *   Обновить эндпоинт логина (`/auth/login` или лучше переделать на `/auth/token` по стандарту OAuth2): должен принимать `username` (email) и `password` через `OAuth2PasswordRequestForm`, проверять их, и в случае успеха генерировать и возвращать `access_token` (и тип токена `bearer`).
    *   Защитить **все** остальные эндпоинты роутера, добавив зависимость `current_user: User = Depends(get_current_active_user)`.
    *   Повторить настройку аутентификации для **каждой роли** (Merchant, Trader, Admin, Support) со своими моделями пользователей и, возможно, отдельными `tokenUrl`.
*   **(Если решено) Аудит Лог:** 
    *   **Задача:** Настроить запись действий пользователей и системы.
    *   **Шаги:**
        *   Убедиться, что модель `AuditLog` добавлена в `db.py` и включена в миграции Alembic.
        *   Создать файл `backend/services/audit_logger.py`.
        *   Реализовать функцию `log_action(...)`, которая создает и добавляет запись `AuditLog` в переданную сессию БД.
        *   Интегрировать вызовы `log_action` в соответствующие места кода (логин, операции CRUD с важными сущностями, смена статусов ордера и т.д.), передавая необходимый контекст (пользователь, действие, цель, детали).
*   **CI/CD:** 
    *   **Задача:** Настроить автоматическую проверку и сборку кода.
    *   **Шаги:**
        *   Выбрать платформу CI/CD (GitHub Actions, GitLab CI, Jenkins и т.д.).
        *   Настроить пайплайн для бэкенда:
            *   Запуск линтеров (Flake8, Black, isort).
            *   Запуск юнит- и интеграционных тестов (Pytest) с использованием тестовой БД.
            *   (Опционально) Сборка Docker-образа.
            *   (Опционально) Публикация артефактов.
*   **Инфраструктура Мониторинга/Логирования:** 
    *   **Задача:** Подготовить инструменты для наблюдения за работой приложения.
    *   **Шаги:**
        *   Настроить проект в Sentry (или аналоге) и получить DSN.
        *   Развернуть (если используется self-hosted) или настроить аккаунты в системах мониторинга метрик (Prometheus/Grafana) и агрегации логов (Loki/Fluentd/ELK stack).
        *   Настроить сбор метрик из FastAPI (например, с `starlette-exporter`) и Worker'а.
        *   Настроить отправку логов приложения в систему агрегации.
*   **Объектное Хранилище (S3):** 
    *   **Задача:** Настроить хранение загружаемых файлов (чеки, документы).
    *   **Шаги:**
        *   Выбрать S3-совместимое хранилище (AWS S3, MinIO, Yandex Object Storage и т.д.).
        *   Получить/создать ключи доступа (`ACCESS_KEY`, `SECRET_KEY`), имя бакета (`BUCKET_NAME`), эндпоинт (`ENDPOINT_URL`).
        *   Добавить эти параметры в конфигурацию приложения.
        *   Добавить зависимость `boto3` (или `aiobotocore` для асинхронных операций) в `requirements.txt`.
        *   Создать утилиту (`utils/s3_client.py` или аналогичный) для инкапсуляции логики загрузки файлов в бакет (например, `upload_file(file_obj, object_name)`).
        *   Реализовать генерацию уникальных имен файлов для избежания коллизий.
        *   Настроить CORS и политики доступа для бакета, если требуется прямой доступ к файлам с фронтенда.
        *   Интегрировать `upload_file` в API эндпоинты, обрабатывающие загрузку файлов (`confirm_payment_by_client`, `confirm_order_by_trader`).
        *   Реализовать обработку ошибок при загрузке файлов.
*   **(Важно) Обнаружение Мошенничества (Fraud Detection):** 
    *   **Задача:** Настроить базовые механизмы анти-фрода.
    *   **Шаги:**
        *   Определить стратегию хранения правил/порогов/списков (конфиг, БД, Redis).
        *   Определить стратегию хранения/обновления velocity-счетчиков (Redis, БД).
        *   Создать сервис `services/fraud_detector.py`.
        *   Реализовать функции `check_incoming_order` и (опционально) `check_order_confirmation`.
        *   Интегрировать вызовы `check_incoming_order` в `services/order_processor.py` (до подбора реквизита) с обработкой результатов (`ALLOW`, `DENY`, `REQUIRE_MANUAL_REVIEW`).
        *   Добавить логирование результатов проверок в `AuditLog`.
        *   Настроить оповещения для статуса `REQUIRE_MANUAL_REVIEW`.
        *   Добавить тесты для различных сценариев фрод-проверок.
*   **Управление Данными Пользователей (GDPR и т.п.):**
    *   **Задача:** Обеспечить возможность обработки запросов субъектов данных.
    *   **Шаги (требуют отдельной проработки, могут быть реализованы позже):**
        *   Реализовать в API администрирования эндпоинты для экспорта данных пользователя (по его ID).
        *   Реализовать механизм безопасного удаления или анонимизации данных пользователя по запросу (с учетом связей и требований законодательства).
        *   Особое внимание уделить удалению/анонимизации PII в `owner_of_requisites` и других местах.
*   **Стратегия Развертывания:**
    *   **Задача:** Минимизировать время недоступности сервиса при обновлениях.
    *   **Рекомендация:** Продумать и реализовать стратегию развертывания без простоя (Zero-Downtime Deployment), например, Blue-Green Deployment или Canary Releases, особенно для production-окружения.

---

## 7. Тестирование

*   Параллельно с разработкой каждого модуля писать юнит-тесты (с mock'ами зависимостей) и интеграционные тесты (с реальной тестовой БД).
*   Особое внимание уделить тестированию:
    *   Логики подбора реквизитов (`requisite_selector`) со всеми граничными условиями (лимиты, статусы, конкурентный доступ).
    *   Логики обработки ордеров (`order_processor`), включая обработку ошибок и обновление статусов (особенно в отдельных транзакциях).
    *   Транзакционности (`atomic_transaction`).
    *   Работы Worker'а (постановка задач, retry, backoff, обработка ошибок задачи).
    *   Обновления балансов.
    *   Логики изменения статусов ордера (`order_status_manager`) и связанных API.
    *   Работы миграций и заполнения данных.
    *   Работы аутентификации и авторизации.
    *   Работы Rate Limiter'а.
    *   **(После наполнения тестовыми данными) Профилирование БД:** Проверить производительность ключевых запросов (особенно в `requisite_selector`, `order_processor`, поиске ордеров/пользователей) с помощью `EXPLAIN ANALYZE`. Оптимизировать запросы и индексы при необходимости.

---

## 8. Зависимости и Интеграция (Перенумерация)

*   Необходимо будет добавить новые зависимости (система очередей, кэширование, Sentry SDK, `python-dotenv`, библиотека для работы с S3-хранилищем, `slowapi`, `redis[hiredis]`, `alembic`, **библиотеки для JWT/OAuth2** и т.д.) в `requirements.txt` и, возможно, в `requirements_worker.txt`.
*   API Роутеры (`backend/api_routers`) должны будут использовать `database.utils` и `utils.exceptions` для создания записей `IncomingOrder` и обработки ошибок.
*   API Роутеры должны вызывать `services.order_status_manager` для изменения статусов ордеров.
*   Система подтверждения статуса ордера (`completed`/`failed`) должна будет вызывать `services.balance_manager.update_balances_for_completed_order` (вероятно, асинхронно через Worker).
*   **Все API эндпоинты (кроме логина) должны требовать аутентификации.**

---

Этот план является основой. В процессе реализации могут возникнуть дополнительные детали или потребоваться корректировки. 