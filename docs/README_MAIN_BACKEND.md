# Бэкенд JivaPay

Этот документ рассказывает о том, как устроен бэкенд JivaPay. Здесь собрана вся важная информация о том, как работает серверная часть, какие у неё есть компоненты и как они взаимодействуют между собой.

## Что мы делаем

Наша цель — создать надёжную и безопасную систему для обработки платежей. Вот основные принципы, которыми мы руководствуемся:

* **Модульность** — разбиваем код на логические части, чтобы его было легче поддерживать и масштабировать
* **Сервисный подход** — каждая часть системы отвечает за свою задачу (например, работа с пользователями или обработка платежей)
* **Надёжность** — следим за тем, чтобы операции с базой данных были атомарными, правильно обрабатываем ошибки и ведём логи
* **Безопасность** — используем HTTPS, JWT для авторизации и защищаемся от атак
* **Гибкая настройка** — храним настройки и в переменных окружения, и в базе данных
* **Тонкая настройка прав** — для админов, саппортов и тимлидов реализована система детальных прав доступа

## Как устроен проект

Бэкенд написан на Python с использованием FastAPI. Вот основные папки и их назначение:

* `backend/`
  * `api_routers/` — API эндпоинты, разделённые по ролям и функциям
    * `common/` — общие эндпоинты для всех ролей
    * Остальные роутеры сгруппированы по ролям (`admin`, `gateway`, `merchant` и т.д.)
  * `config/` — настройки системы
    * `logger.py` — настройка логирования
    * `crypto.py` — работа с шифрованием
    * `settings.py` — загрузка настроек
  * `database/` — работа с базой данных
    * `db.py` — модели SQLAlchemy
    * `engine.py` — настройка подключения к БД
    * `utils.py` — утилиты для работы с БД
    * `utils_async.py` — асинхронные версии утилит
    * `migrations/` — миграции базы данных
  * `middleware/` — промежуточные обработчики
    * `rate_limiting.py` — ограничение частоты запросов
    * `request_logging.py` — логирование запросов
  * `schemas_enums/` — схемы данных и перечисления
  * `scripts/` — вспомогательные скрипты
    * `manage_db.py` — управление базой данных
    * Сидеры для начальных данных
  * `security.py` — аутентификация и авторизация
  * `servers/` — точки входа для разных API
  * `services/` — бизнес-логика
  * `utils/` — общие утилиты
  * `worker/` — фоновые задачи

## Настройка и запуск

### Где хранятся настройки

У нас есть два места для настроек:

1. **Переменные окружения** (`.env` файл)
   - Храним секреты (пароли, ключи)
   - Базовые настройки подключения к БД, Redis, Sentry, S3
   - JWT ключи

2. **База данных** (таблица `configuration_settings`)
   - Настройки, которые можно менять без перезапуска
   - Лимиты API
   - Настройки анти-фрода
   - Таймауты для ордеров
   - Настройки повторных попыток

Для чтения настроек используем:
- `get_typed_config_value` — для обычных функций
- `get_typed_config_value_async` — для асинхронных функций

### Секреты

В production используем специальные системы для хранения секретов:
- HashiCorp Vault
- Облачные решения
- K8s Secrets

## Основные компоненты

### Авторизация и права

Как мы работаем с пользователями:

* **Авторизация**
  - Используем JWT токены
  - Хешируем пароли через bcrypt
  - У каждого типа пользователя свой эндпоинт для входа

* **Права доступа**
  - Для админов, саппортов и тимлидов есть система детальных прав
  - Права хранятся в JSON поле `granted_permissions`
  - Проверяем права через `permission_service`

### База данных

Как мы работаем с данными:

* **Модели** (`db.py`)
  - Все основные таблицы системы
  - Недавно добавили:
    - Поле `is_traffic_enabled_by_teamlead` для трейдеров
    - Поле `granted_permissions` для профилей
    - Поле `role_description` для саппортов
    - Поле `level` в `AuditLog`

* **Утилиты**
  - `get_db_session()` — для FastAPI
  - `get_db_session_cm()` — для сервисов
  - `atomic_transaction()` — для атомарных операций
  - CRUD функции для работы с данными
  - Асинхронные версии всех утилит

### Обработка ошибок и логи

Как мы следим за системой:

* **Исключения**
  - Своя иерархия ошибок
  - Декоратор `@handle_service_exceptions` для логирования
  - Глобальные обработчики в FastAPI

* **Логирование**
  - Структурированные JSON логи
  - Логируем все запросы
  - Отправляем критические ошибки в Sentry

### Промежуточные обработчики

Что происходит между запросом и ответом:

* **Ограничение запросов**
  - Используем Redis для rate limiting
  - Лимиты можно менять через БД
  - Есть fallback на in-memory для разработки

* **Логирование запросов**
  - Записываем метод, путь, статус
  - Измеряем время выполнения
  - Используем отдельный логгер

### Сервисы

Основная бизнес-логика:

* **Работа с пользователями** (`user_service.py`)
  - Создание и авторизация
  - Управление профилями
  - Работа с ролями

* **Права доступа** (`permission_service.py`)
  - Проверка прав
  - Поддержка wildcard в правах
  - Документированная логика проверки

* **Аудит** (`audit_service.py`)
  - Запись событий в БД
  - Асинхронная версия
  - Уровни важности событий

* **Подбор реквизитов** (`requisite_selector.py`)
  - Поиск подходящего реквизита
  - Проверка доступности
  - Round-robin распределение
  - Асинхронная версия

* **Обработка ордеров** (`order_processor.py`)
  - Проверка идемпотентности
  - Атомарные транзакции
  - Проверка на фрод
  - Обработка чеков

* **Балансы** (`balance_manager.py`)
  - Расчет комиссий
  - Обновление балансов
  - История операций
  - Асинхронные версии

* **Статусы ордеров** (`order_status_manager.py`)
  - Управление статусами
  - Подтверждение платежей
  - Обработка споров
  - Асинхронные операции

* **Ордера** (`order_service.py`)
  - Создание ордеров
  - Фильтрация и поиск
  - Статистика
  - Проверка прав

* **Реквизиты** (`requisite_service.py`)
  - Статистика активных реквизитов
  - Модерация
  - Управление статусами

* **Платформа** (`platform_service.py`)
  - Балансы платформы
  - Агрегированная статистика

* **Трейдеры** (`trader_service.py`)
  - Статистика по трейдерам
  - Детальная информация
  - Фильтрация для саппортов

* **Мерчанты** (`merchant_service.py`)
  - Управление магазинами
  - Статистика
  - Настройки

## 1. Введение

Этот документ представляет собой консолидированное описание бэкенд-системы JivaPay. Он объединяет информацию из планов реализации, описаний компонентов, утилит и дополнительных функций, предоставляя полное представление об архитектуре, ключевых модулях и их взаимодействии.

**Цель:** Служить центральным справочником по бэкенду для разработчиков, обеспечивая понимание его структуры, логики работы и принципов проектирования.

**Основные принципы:**
*   **Модульность:** Компоненты бэкенда разделены на логические модули (сервисы, утилиты, API-роутеры) для улучшения сопровождаемости и масштабируемости.
*   **Сервис-ориентированный подход:** Бизнес-логика инкапсулирована в сервисах, каждый из которых отвечает за свою область (например, управление пользователями, обработка ордеров, подбор реквизитов). API-роутеры делегируют выполнение бизнес-логики сервисам.
*   **Надежность и отказоустойчивость:** Особое внимание уделяется атомарности операций с базой данных, обработке ошибок (с использованием кастомных исключений и декоратора `@handle_service_exceptions`), стандартизированному логированию (через `backend.config.logger.get_logger()`) и механизмам фоновой обработки задач (Celery).
*   **Безопасность:** Взаимодействие с API осуществляется по HTTPS, используются JWT для аутентификации, предусмотрены механизмы авторизации и защиты от распространенных атак (например, rate limiting).
*   **Централизованное управление конфигурацией:** Настройки приложения хранятся как в переменных окружения (для секретов и базовых подключений), так и в базе данных (для параметров, изменяемых "на лету").
*   **Гранулярное управление правами:** Для ролей Администратора, Саппорта и Тимлида реализована система гранулярных прав доступа, хранящихся в JSON-полях профилей пользователей и проверяемых через `permission_service`.

---

## 2. Архитектура и Структура Проекта

Бэкенд JivaPay построен на Python с использованием фреймворка FastAPI. Ключевые директории и их назначение:

*   `backend/`
    *   `api_routers/`: Содержит API-роутеры, разделенные по ролям и функциональным областям. Обрабатывают HTTP-запросы, валидируют данные и **полностью делегируют выполнение бизнес-логики соответствующим сервисам.** Логика, связанная с обработкой файлов (например, чтение байтов загружаемого файла), может оставаться в роутерах перед передачей данных в сервис.
        *   `common/`: Общие эндпоинты, используемые разными ролями (например, для ордеров, магазинов).
        *   Роутеры сгруппированы по основным сущностям или ролям (`admin`, `gateway`, `merchant`, `public_router`, `support`, `teamlead`, `trader`).
    *   `config/`: Конфигурационные файлы, включая настройку логгера (`logger.py`), криптографию (`crypto.py`) и загрузку настроек приложения (`settings.py`).
    *   `database/`: Модули для работы с базой данных.
        *   `db.py`: Определения SQLAlchemy моделей. Внесены изменения: `AuditLog` получило поле `level`.
        *   `engine.py`: Инициализация SQLAlchemy engine и сессии.
        *   `utils.py`: Утилиты для работы с сессиями, транзакциями и CRUD-операции.
        *   `utils_async.py`: Асинхронные аналоги утилит из `utils.py` для работы с `AsyncSession`.
        *   `migrations/`: Скрипты Alembic для миграций схемы БД.
    *   `middleware/`: Middleware для FastAPI:
        *   `rate_limiting.py`: Ограничение частоты запросов с использованием `slowapi` и Redis. Настройки лимитов могут подгружаться из БД. Использует `get_logger`.
        *   `request_logging.py`: Логирование каждого входящего HTTP-запроса и времени его выполнения. Использует `get_logger`.
    *   `schemas_enums/`: Pydantic-схемы для валидации данных API и Python Enums.
    *   `scripts/`: Вспомогательные скрипты:
        *   `manage_db.py`: CLI на базе Click для инициализации БД и запуска сидеров.
        *   Сидеры (`seed_config.py`, `seed_data.py`, `seed_payment_references.py`, `seed_reference_data.py`) для наполнения БД начальными данными. `seed_data.py` обновлен для использования `granted_permissions` при создании администратора и использует кастомный логгер `get_logger`.
    *   `security.py`: Функции и зависимости для аутентификации (JWT) и авторизации.
    *   `servers/`: Точки входа FastAPI-приложений для каждой основной группы API (`admin/`, `merchant/`, `support/`, `teamlead/`, `trader/`, `gateway/`). Каждое приложение настраивает свои роутеры, middleware (включая rate limiting где применимо) и обработчики исключений. Некоторые файлы (`gateway/server.py`, `teamlead/server.py`) были очищены от избыточного логирования конфигурации.
    *   `services/`: Инкапсуляция основной бизнес-логики. Большинство публичных методов сервисов обернуты декоратором `@handle_service_exceptions`.
    *   `utils/`: Вспомогательные утилиты общего назначения:
        *   `decorators.py`: Содержит `@handle_service_exceptions`, который теперь поддерживает и синхронные, и асинхронные функции.
        *   `query_filters.py`: Централизованные функции для генерации SQLAlchemy фильтров (`get_active_trader_filters`, `get_active_requisite_filters`).
        *   `exceptions.py`, `notifications.py`, `s3_client.py` (содержит асинхронную функцию `upload_fileobj_async`), `config_loader.py` (теперь с асинхронными аналогами и `asyncache`), `exception_handlers.py`, `health.py`, `query_utils.py`.
    *   `worker/`: Реализация фонового обработчика задач (Celery).
        *   `app.py`: Настройка Celery приложения (брокер, бэкенд результатов).
        *   `tasks.py`: Определение задач Celery (например, `process_order_task` для обработки входящих ордеров, `update_balance_task` для обновления балансов). Задачи используют кастомный логгер `get_logger` и настроенные механизмы retry. `process_order_task` загружает конфигурацию retry из БД и использует `report_critical_error` при сбое загрузки конфигурации.

---

## 3. Конфигурация и Запуск

### 3.1. Переменные Окружения и Настройки в БД

*   **Переменные Окружения (`.env`):** Используются для хранения секретов и базовых параметров подключения (к БД, Redis, Sentry, S3), JWT-ключей.
*   **Настройки в Базе Данных (таблица `configuration_settings`):** Параметры, которые могут потребовать изменения без перезапуска приложения (лимиты API, настройки анти-фрода, таймауты ордеров, множители для retry). Читаются через `backend.utils.config_loader.get_typed_config_value` (синхронно) или `backend.utils.config_loader.get_typed_config_value_async` (асинхронно). Для кэшируемых справочников (например, в `reference_data.py`) предусмотрены механизмы инвалидации кэша.

### 3.2. Управление Секретами

Для **production** окружения рекомендуется использовать специализированные системы управления секретами (HashiCorp Vault, облачные аналоги, K8s Secrets).

---

## 4. Ключевые Компоненты и Сервисы Бэкенда

### 4.1. Аутентификация и Авторизация

*   **Механизм:** JWT (JSON Web Tokens) / OAuth2.
*   **Утилиты:**
    *   `backend.security`: Генерация/валидация токенов (`create_access_token`, `verify_access_token`), получение текущего пользователя (`get_current_user`, `get_current_active_user`).
    *   `backend.config.crypto`: Хеширование паролей (`hash_password`, `verify_password`) с использованием bcrypt.
*   **Эндпоинты логина:** Реализованы для каждой роли. Роутер аутентификации для тимлидов (`backend/api_routers/teamlead/auth.py`) рефакторен для использования `user_service.authenticate_user`.
*   **Защита эндпоинтов:** Используются зависимости FastAPI Security (`Depends(get_current_active_user)` или специфичные для роли).
*   **Гранулярные права:** Для ролей Admin, Support, TeamLead права доступа определяются JSON-полем `granted_permissions` в их профилях и проверяются через `services.permission_service`.

### 4.2. База Данных (`backend/database/`)

*   **Модели (`db.py`):** Определены все основные сущности системы (см. `docs/README_DATABASE.md`).
    *   **Ключевые обновления:**
        *   В `Trader` добавлено поле `is_traffic_enabled_by_teamlead`.
        *   В профилях `Admin`, `Support`, `TeamLead` добавлены поля `granted_permissions`. В `AdminProfile` старые булевы поля прав удалены.
        *   В `Support` добавлено `role_description`.
        *   Из `FullRequisitesSettings` удалено `active_hours`.
        *   В `AuditLog` добавлено индексируемое поле `level` (String), JSONB поле `details` больше не используется для хранения уровня лога.
*   **Утилиты (`utils.py`):**
    *   `get_db_session()`: Зависимость FastAPI для предоставления сессии БД.
    *   `get_db_session_cm()`: Контекстный менеджер для сессий в сервисах/воркерах.
    *   `atomic_transaction()`: Декоратор/контекстный менеджер для атомарных транзакций с автоматическим COMMIT/ROLLBACK и логированием.
    *   CRUD-функции (`create_object`, `get_object_or_none`, `update_object_db`) с обработкой исключений SQLAlchemy и логированием.
    *   **Асинхронные аналоги (`utils_async.py`):** Предоставляют схожий функционал (`get_async_db_session_cm`, `atomic_transaction_async`, `create_object_async`, `get_object_or_none_async`, `update_object_db_async`) для работы с `AsyncSession`.

### 4.3. Обработка Ошибок и Логирование

*   **Кастомные Исключения (`utils.exceptions.py`):** Иерархия исключений, наследуемых от `JivaPayException`.
*   **Декоратор `@handle_service_exceptions` (`utils.decorators.py`):**
    *   Применяется к большинству публичных синхронных и асинхронных функций/методов сервисов (поддержка асинхронности реализована через `inspect.iscoroutinefunction`).
    *   Перехватывает `JivaPayException` (логирует как ERROR и перевыбрасывает) и другие `Exception` (логирует как CRITICAL, может отправлять в Sentry, и перевыбрасывает).
    *   Логирует успешное выполнение и, опционально, результат.
    *   Использует логгер, полученный через `backend.config.logger.get_logger()`.
*   **Глобальные Обработчики Исключений (`utils.exception_handlers.py`):** Зарегистрированы в FastAPI-приложениях для `JivaPayException` и стандартных ошибок FastAPI. Формируют стандартизированный JSON-ответ.
*   **Логгер (`config/logger.py`):**
    *   Функция `get_logger(name: str, level: Optional[str] = None)` для получения экземпляра логгера. Используется повсеместно вместо стандартного `logging.getLogger()`.
    *   Настроен на структурированный JSON-вывод.
*   **Уведомления (`utils.notifications.py`):**
    *   Функция `report_critical_error(exception, context_message, **kwargs)` для отправки критических ошибок в Sentry (или аналогичную систему).

### 4.4. Middleware

*   **Ограничение Частоты Запросов (`middleware/rate_limiting.py`):**
    *   Использует `slowapi` и Redis (с fallback на in-memory для разработки).
    *   URL Redis конфигурируется через переменную окружения `REDIS_URL`.
    *   Дефолтный лимит (`RATE_LIMIT_DEFAULT`) загружается из БД.
    *   Применяется в FastAPI-приложениях (`servers/*`), где это необходимо (например, `gateway`, `merchant`, `trader`).
    *   Использует кастомный логгер `get_logger(__name__)`.
    *   Удалены дублирующиеся комментарии, улучшена документация по применению лимитов.
*   **Логирование Запросов (`middleware/request_logging.py`):**
    *   Логирует информацию о каждом входящем HTTP-запросе (метод, путь) и ответе (статус, время выполнения).
    *   Использует кастомный логгер `get_logger("request_logger")`.
*   **Другие Middleware:** CORS (если необходимо).

### 4.5. Сервисы Бизнес-Логики (`backend/services/`)

Все сервисы, где это применимо, используют декоратор `@handle_service_exceptions` для унифицированного логирования и обработки ошибок. Логика максимально вынесена из API роутеров в сервисы.

#### 4.5.1. `user_service.py` (Сервис Пользователей)
*   **Назначение:** Управление пользователями, ролями, профилями.
*   **Функционал:**
    *   Предоставляет `get_all_users_basic` для получения базового списка пользователей (используется `api_routers.admin.users`).
    *   `authenticate_user` используется для проверки учетных данных (например, в `api_routers.teamlead.auth`).
    *   Остальной функционал как описано ранее, с учетом применения декоратора и делегирования из роутеров.

#### 4.5.2. `permission_service.py` (Сервис Управления Правами)
*   **Назначение:** Централизованное управление и проверка гранулярных прав доступа.
*   **Функционал:**
    *   `check_permission` используется для проверки прав (например, в `api_routers.admin.users`).
    *   Логика `_match_permission` была детально документирована (комментарии и docstrings) для разъяснения поведения wildcard и формата прав.
    *   Остальной функционал как описано ранее.

#### 4.5.3. `audit_service.py` (Сервис Аудита, ранее `audit_logger.py`)
*   **Назначение:** Запись событий аудита в систему.
*   **Функционал:**
    *   Файл переименован из `audit_logger.py`.
    *   Функция `log_event` записывает события в таблицу `AuditLog`.
    *   Реализована асинхронная версия `log_event_async` для использования с `AsyncSession`.
    *   Уровень события (`level`) теперь пишется в отдельное индексируемое строковое поле `AuditLog.level`.
    *   Собственное логирование сервиса аудита теперь использует уровень, соответствующий уровню события (через `logger.log(logging.getLevelName(level.upper()), ...)`).
    *   `get_critical_system_errors` фильтрует по новому полю `level`.

#### 4.5.4. `requisite_selector.py` (Подбор Реквизитов)
*   **Назначение:** Инкапсуляция логики поиска и выбора подходящего реквизита трейдера для входящей заявки. **Критически важный** компонент.
*   **Функционал (`find_suitable_requisite`):**
    *   Работает внутри транзакции, управляемой извне (из `order_processor`).
    *   **Условия доступности трейдера/реквизита:** Как описано ранее.
    *   Использует `backend.utils.query_filters.get_active_trader_filters()` и `get_active_requisite_filters()`.
    *   Выполняет SQL-запрос с пессимистической блокировкой `with_for_update(of=[ReqTrader, FullRequisitesSettings, Trader, User], skip_locked=True)` на этапе выборки кандидатов для обеспечения консистентности лимитов.
    *   Использует `datetime.now(timezone.utc)` вместо `datetime.utcnow()` для корректной работы с таймзонами.
    *   **Round-robin:** Сортировка по `Trader.trafic_priority` (ASC), затем `ReqTrader.last_used_at` (ASC, NULLS FIRST).
    *   Обновляет `ReqTrader.last_used_at` после назначения.
    *   Проверяет динамические лимиты реквизита.
    *   Возвращает `(requisite_id, trader_id)` или `None`.
*   **Асинхронная версия (`find_suitable_requisite_async`):**
    *   Предоставляет аналогичный функционал для работы с `AsyncSession`.
    *   Также использует пессимистическую блокировку и условия доступности.
    *   Обернут декоратором `@handle_service_exceptions`.

#### 4.5.5. `order_processor.py` (Обработка Входящих Заявок)
*   **Назначение:** Оркестрация обработки одной входящей заявки (`IncomingOrder`), включая новый асинхронный поток для финализации ордера после подтверждения клиентом на странице шлюза.
*   **Функционал (`process_incoming_order` - синхронный, для старых потоков или задач Celery):**
    1.  **Проверка идемпотентности.**
    2.  Начало основной атомарной транзакции.
    3.  Загрузка `IncomingOrder` с блокировкой (`with_for_update`).
    4.  Вызов `fraud_detector.check_incoming_order()`.
    5.  Вызов `requisite_selector.find_suitable_requisite()`.
    6.  **Результат `find_suitable_requisite`:** Как описано ранее.
    *   Обработка `FraudDetectedError` была улучшена: статусы `DENY` и `REQUIRE_MANUAL_REVIEW` теперь приводят к финальным состояниям ордера и не проходят через стандартную логику retry для этих случаев.
*   **Новый асинхронный функционал (`finalize_order_after_client_confirmation_async`):**
    *   **Назначение:** Выполняет основную логику обработки ордера после того, как клиент подтвердил оплату на выделенной странице платежного шлюза.
    *   **Вызывается из:** `gateway_service.handle_payment_page_confirmation` после успешного вызова `order_status_manager.confirm_payment_from_gateway_page`.
    *   **Ключевые операции (выполняются в рамках `atomic_transaction_async`):**
        1.  Загрузка `IncomingOrder` и связанной `PaymentSession`.
        2.  Загрузка порогов для фрод-детектора с использованием `get_typed_config_value_async` из `config_loader.py`.
        3.  Вызов асинхронного `fraud_detector.check_incoming_order_async` с передачей загруженных порогов.
        4.  Вызов асинхронного `requisite_selector.find_suitable_requisite_async` для подбора реквизита.
        5.  Вызов асинхронного `balance_manager.calculate_commissions_async` для расчета комиссий.
        6.  Создание записи `OrderHistory` (статус `pending`).
        7.  Если передан чек (`receipt_content`, `receipt_filename`):
            *   Загрузка файла чека в S3 с использованием `s3_client.upload_fileobj_async`.
            *   Создание записи `UploadedDocument`, связывающей чек с `OrderHistory` и `IncomingOrder`.
        8.  Обновление статусов `IncomingOrder` (например, на `processed` или `failed_processing_receipt`) и `PaymentSession` (например, на `completed` или `completed_with_issues`) на основе результатов выполнения.
        9.  Логирование событий аудита с использованием `audit_service.log_event_async`.
    *   **Обработка ошибок:** Включает специфическую обработку `FraudDetectedError`, `RequisiteNotFound` и других исключений с обновлением статусов `IncomingOrder` и `PaymentSession` соответствующим образом внутри транзакции. Неожиданные ошибки логируются и репортятся.

#### 4.5.6. `balance_manager.py` (Управление Балансами)
*   **Назначение:** Надежное обновление балансов и запись истории. Выполняется после успешного подтверждения ордера.
*   **Функционал:**
    *   `calculate_commissions()`: Расчет комиссий магазина и трейдера на основе `StoreCommission`, `TraderCommission`.
    *   `update_balances_for_completed_order()`:
        *   Логика для `net_store_change` была проверена и подтверждена как корректно обрабатывающая `order.order_type`.
        *   Работает в атомарной транзакции.
        *   Загружает `OrderHistory`, `MerchantStore`, `Trader`.
        *   Блокирует строки балансов (`BalanceStore`, `BalanceTrader`, `BalancePlatform`) для обновления.
        *   Обновляет балансы.
        *   Создает записи в `BalanceStoreHistory`, `BalanceTraderFiatHistory`, `BalanceTraderCryptoHistory`, `BalancePlatformHistory` (фиксируя `platform_profit`).
*   **Асинхронные аналоги:**
    *   `calculate_commissions_async()`: Асинхронная версия для расчета комиссий.
    *   `update_balances_for_completed_order_async()`: Асинхронная версия для обновления балансов.
        *   **Автоматическое создание балансов:** Если записи `BalanceStore` или `BalanceTrader` для соответствующего магазина/криптовалюты или трейдера/фиата не существуют, они создаются с нулевым балансом "на лету" внутри той же атомарной транзакции перед применением изменений.

#### 4.5.7. `order_status_manager.py` (Управление Статусами Ордера)
*   **Назначение:** Логика перехода `OrderHistory` и `IncomingOrder` между статусами. Сервис был рефакторен для работы с `AsyncSession`.
*   **Функционал:**
    *   `confirm_payment_from_gateway_page()`: Для PayIn, вызывается из `gateway_service.handle_payment_page_confirmation` после того, как клиент подтвердил действия на уникальной странице оплаты шлюза. Обновляет статус `IncomingOrder` на `client_payment_confirmed`. Логирует событие аудита. Создание `OrderHistory` и обработка чека теперь делегированы `order_processor.finalize_order_after_client_confirmation_async`.
    *   `confirm_order_by_trader()` (async): Трейдер подтверждает ордер (загрузка чека для PayOut). Статус `OrderHistory` -> `completed`. **Инициирует** `balance_manager.update_balances_for_completed_order_async`.
    *   `cancel_order()` (async), `dispute_order()` (async), `resolve_dispute()` (async), `fail_order()` (async): Асинхронная обработка отмены, споров, неудачи.
    *   Все операции в атомарных транзакциях (async). Использует `audit_service.log_event_async`.

#### 4.5.8. `order_service.py` (Сервис Ордеров)
*   **Назначение:** Расширенные возможности для работы с историей ордеров и создание ордеров.
*   **Функционал:**
    *   Созданы новые функции для делегирования логики из API роутеров:
        *   `get_orders_for_trader(current_trader: Trader, ...)`: Используется `api_routers.common.trader_orders`. Аннотация типа `current_trader_user: User` изменена на `current_trader: Trader`.
        *   `get_orders_for_merchant(current_merchant: Merchant, ...)`: Используется `api_routers.common.merchant_orders`. Аннотация типа `current_merchant_user: User` изменена на `current_merchant: Merchant`.
        *   `create_order_from_incoming(incoming_data: IncomingOrderData, ...)`: Используется `api_routers.common.merchant_orders` для создания ордера.
    *   `get_orders_history()`: Выборка ордеров с комплексной фильтрацией (сумма, диапазон дат, статус, ID, email, поиск по полям), сортировкой, пагинацией. Использует `utils.query_utils.py` и `permission_service` для проверки прав.
    *   `get_orders_count()`: Подсчет количества ордеров с фильтрами и учетом прав.

#### 4.5.9. `requisite_service.py` (Сервис Реквизитов)
*   **Назначение:** Управление и предоставление статистики по реквизитам.
*   **Функционал:**
    *   `get_online_requisites_stats()`: Статистика активных реквизитов с фильтрацией, сортировкой. Функция была рефакторена для использования `outerjoin` для `PaymentMethod` и `Bank` в основном запросе, что упростило логику условных join'ов. В результат добавлены `payment_method_name` и `bank_name`.
    *   `get_requisite_details_for_moderation()`: Детали реквизита для админов.
    *   `set_requisite_status()`: Установка статуса реквизита админом с аудитом.

#### 4.5.10. `platform_service.py` (Сервис Платформы)
*   **Назначение:** Информация о состоянии платформы.
*   **Функционал:**
    *   `get_platform_balances()`: Агрегированные балансы платформы из `BalancePlatform`.
    *   Проблем в ходе анализа не обнаружено.

#### 4.5.11. `trader_service.py` (Сервис Трейдеров)
*   **Назначение:** Статистика и детальная информация по трейдерам.
*   **Функционал:**
    *   Декоратор `@handle_service_exceptions` применен к публичным методам `get_traders_statistics` и `get_trader_full_details`.
    *   Функция `get_traders_statistics` была декомпозирована для улучшения читаемости: специфичная для роли "support" логика фильтрации вынесена в приватный метод `_apply_support_specific_filters`, а создание агрегирующих SQL подзапросов — в `_get_trader_aggregate_subqueries`. Поля `statistics_columns` корректно включаются в результат.
    *   `get_trader_full_details()`: Полная информация о трейдере для админов.

#### 4.5.12. `merchant_service.py` (Сервис Мерчантов)
*   **Назначение:** Аналогично `trader_service`, но для мерчантов. Управление магазинами мерчантов.
*   **Функционал:**
    *   Реализованы CRUD-функции для магазинов (`MerchantStore`), которые вызываются из `api_routers.common.stores`:
        *   `create_merchant_store()`
        *   `get_merchant_stores()` (ранее `get_stores_for_merchant`)
        *   `update_merchant_store()`
        *   `delete_merchant_store()`
    *   `get_merchants_statistics()`: Статистика с фильтрацией, сортировкой. Использует `utils.query_utils.py` и `permission_service`.
    *   `get_merchant_full_details()`: Полная информация о мерчанте.

#### 4.5.13. `teamlead_service.py` (Сервис Тимлидов)
*   **Назначение:** Функционал для роли Тимлида.
*   **Функционал:**
    *   Созданы новые функции для делегирования логики из API роутеров (`api_routers.common.teamlead_traders`):
        *   `list_traders_for_teamlead(current_teamlead: TeamLead, ...)`
        *   `set_trader_in_work_status_by_teamlead(current_teamlead: TeamLead, ...)`
    *   Аннотация типа для `current_teamlead_user: User` изменена на `current_teamlead: TeamLead` в соответствующих функциях.
    *   Расчет статистики команды в `get_team_statistics` вынесен в приватный метод `_calculate_team_stats`.
    *   В `_calculate_team_stats` исправлены вызовы фильтров на корректные `get_active_trader_filters` и `get_active_requisite_filters`.
    *   `get_managed_traders()`: Список трейдеров команды (возвращает базовую информацию).
    *   `set_trader_traffic_status_by_teamlead()`: Установка флага `Trader.is_traffic_enabled_by_teamlead` с аудитом.
    *   `get_teamlead_full_details()`: Полная информация о тимлиде (для админов).

#### 4.5.14. `reference_data.py` (Сервис Справочных Данных)
*   **Назначение:** Предоставление справочных данных (банки, валюты, платежные методы, курсы) с кэшированием.
*   **Функционал:**
    *   Реализованы функции для инвалидации кэша при изменении данных в БД: `invalidate_bank_cache(bank_id)`, `invalidate_payment_method_cache(pm_id)`, `invalidate_exchange_rate_cache(pair)`.
    *   В `get_bank_details` добавлена нетерпеливая загрузка (`joinedload`) для связи `Bank.fiat` для оптимизации запросов при кэшировании.
    *   Использует кэширование (потенциально Redis, настраивается через `config_loader`).

#### 4.5.15. `callback_service.py` (Сервис Колбэков)
*   **Назначение:** Отправка колбэков мерчантам о событиях ордеров.
*   **Функционал:**
    *   Уточнена логика определения `callback_url`: приоритет отдается URL, указанному в конкретном ордере, затем используется URL по умолчанию из настроек магазина (`MerchantStore`).
    *   Реализован механизм повторных попыток отправки колбэков с использованием `httpx` для HTTP-запросов и `asyncio.sleep` для задержек между попытками.
    *   Структура payload колбэка была расширена и более четко определена (включая `order_id`, `status`, `external_order_id`, `amount_fiat`, `currency_fiat`, `amount_crypto`, `currency_crypto`, `timestamp`, `signature`).

#### 4.5.16. `fraud_detector.py` (Сервис Обнаружения Фрода)
*   **Назначение:** Проверка входящих ордеров на мошеннические операции.
*   **Функционал:**
    *   В функции `check_incoming_order` обновлена логика: если при проверке `amount_fiat` отсутствует в данных ордера (`IncomingOrderData`), то вызывается исключение `FraudDetectedError` со статусом `FraudStatus.REQUIRE_MANUAL_REVIEW`. Это предотвращает автоматическое одобрение ордеров без достаточных данных для проверки.
    *   **Асинхронная версия (`check_incoming_order_async`):** Предоставляет аналогичный функционал для работы с `AsyncSession`. Пороги фрода (manual, deny) передаются как аргументы функции, что упрощает ее использование в асинхронном контексте и тестирование.

#### 4.5.17. `gateway_service.py` (Сервис Платежного Шлюза)
*   **Назначение:** Обработка запросов от внешних систем к платежному шлюзу, таких как инициализация платежей и получение их статусов, а также управление жизненным циклом уникальных страниц оплаты. Сервис был рефакторен в асинхронный класс `GatewayService(BaseService)`.
*   **Функционал:**
    *   `initiate_payment_session`: (Ранее `initialize_payin_session`) Принимает данные для инициации Pay-In. Создает `IncomingOrder` и `PaymentSession` с уникальным токеном и ограниченным временем жизни. Формирует уникальный URL (например, `https://pay.example.com/{token}`), который будет возвращен мерчанту для редиректа клиента. Сохраняет токен и детали сессии в БД.
    *   `get_payment_session_details`: (Ранее `get_payment_session_details_by_token`) Используется уникальной страницей оплаты для получения деталей активной и не истекшей сессии (`PaymentSession`).
    *   `handle_payment_page_confirmation`: Вызывается бэкенд-логикой уникальной страницы оплаты, когда клиент завершает на ней процесс оплаты (например, загружает чек и подтверждает). Принимает данные чека и токен сессии.
        1.  Вызывает `order_status_manager.confirm_payment_from_gateway_page` для обновления статуса `IncomingOrder` на `client_payment_confirmed`.
        2.  Затем вызывает `order_processor.finalize_order_after_client_confirmation_async` для выполнения основной логики: фрод-чек, подбор реквизита, создание `OrderHistory`, загрузка чека в S3, создание `UploadedDocument`, расчет комиссий и обновление статусов `IncomingOrder` и `PaymentSession`.
    *   `get_incoming_order_status`: (Ранее `get_payin_status`) Позволяет мерчанту проверить статус операции Pay-In по `external_order_id`, `incoming_order_id` или `payment_token`. Возвращает также `payment_url` и `order_history_status`.
    *   Эндпоинты для PayOut (`initialize_payout`, `get_payout_status`) остаются, но также адаптированы для работы с асинхронным сервисом.
    *   Старые эндпоинты (`legacy_handle_init_request`, `legacy_handle_client_confirmation_api`) сохранены, но помечены для пересмотра/удаления.

### 4.6. Фоновая Обработка Задач (`backend/worker/`)

*   **Технология:** Celery с Redis в качестве брокера сообщений и бэкенда результатов.
*   **Основные задачи (`tasks.py`):**
    *   **`process_order_task`**:
        *   Обрабатывает входящие ордера (`IncomingOrder`).
        *   Использует `acks_late=True` для подтверждения сообщения после выполнения задачи.
        *   Реализована кастомная логика повторных попыток для инфраструктурных ошибок (`DatabaseError`, `CacheError`) с экспоненциальной задержкой. Параметры `MAX_ORDER_RETRIES` и `RETRY_DELAY_SECONDS` загружаются из БД через `get_typed_config_value`.
        *   В случае невозможности загрузить конфигурацию retry из БД, логируется ошибка и вызывается `report_critical_error` для уведомления.
        *   Бизнес-ошибки (`OrderProcessingError`), которые должны быть обработаны в `order_processor`, не вызывают повторных попыток на уровне задачи Celery; задача считается выполненной, так как логика обработки ошибки инкапсулирована ниже.
        *   Неожиданные ошибки (`Exception`) логируются как CRITICAL, уведомляются через `report_critical_error` и приводят к отклонению задачи без повторной постановки в очередь (`Reject(requeue=False)`), чтобы избежать циклов ошибок.
    *   **`update_balance_task`**:
        *   Асинхронно обновляет балансы для завершенного ордера, вызывая `balance_manager.update_balances_for_completed_order`.
        *   Использует `acks_late=True` и стандартную политику retry Celery при возникновении ошибок (`raise self.retry(exc=e)`).
    *   **`poll_new_orders_task` (закомментирована)**: Потенциальная задача для периодического опроса базы данных на предмет "новых" или "зависших на retry" ордеров и их постановки в очередь на обработку. Её актуальность и необходимость требуют дополнительного уточнения.
*   **Логгирование:** Все задачи в `tasks.py` используют кастомный логгер, полученный через `get_logger(__name__)`, для обеспечения консистентного логирования.

### 4.7. Скрипты (`backend/scripts/`)

*   **Назначение:** Вспомогательные операции, такие как инициализация БД и наполнение её начальными данными (сидинг).
*   **Основные скрипты:**
    *   `manage_db.py`: CLI-утилита на базе Click для управления базой данных (инициализация, запуск всех сидеров).
    *   `seed_data.py`: Заполняет таблицы `Role`, `User`, `Admin`. При создании администратора теперь используется поле `Admin.granted_permissions = ["*:*:*"]` вместо старых булевых полей прав. Скрипт обновлен для использования `get_logger(__name__)`.
    *   `seed_reference_data.py`: Заполняет справочники стран и валют.
    *   `seed_payment_references.py`: Заполняет справочники платежных методов, банков, их доступности.
    *   `seed_config.py`: Заполняет таблицу `ConfigurationSetting` начальными настройками.
*   **Логгирование:** В `seed_data.py` используется `get_logger`. Для остальных скриптов (`seed_reference_data.py`, `seed_payment_references.py`, `seed_config.py`, `manage_db.py`) также рекомендовано перейти на `get_logger` для полной консистентности логирования в проекте.

---

## 5. API Роутеры и Делегирование Логики

Ключевым изменением в архитектуре стало последовательное вынесение бизнес-логики из API роутеров (`backend/api_routers/`) в соответствующие сервисы (`backend/services/`).

*   **Общий принцип:** Роутеры отвечают за прием HTTP-запросов, валидацию данных (через Pydantic схемы), аутентификацию/авторизацию (через зависимости FastAPI) и затем вызывают методы сервисов для выполнения основной работы.
*   **Примеры рефакторинга:**
    *   `backend/api_routers/admin/users.py`: Логика проверки прав и получения списка пользователей перенесена в `permission_service` и `user_service`.
    *   `backend/api_routers/common/teamlead_traders.py`: Логика листинга трейдеров и изменения их статуса перенесена в `teamlead_service`.
    *   `backend/api_routers/teamlead/auth.py`: Эндпоинт `/auth/token` теперь использует `user_service.authenticate_user`.
    *   `backend/api_routers/common/trader_orders.py` и `backend/api_routers/common/merchant_orders.py`: Логика работы с ордерами (создание, листинг) перенесена в `order_service`.
    *   `backend/api_routers/common/stores.py`: CRUD-операции для магазинов делегированы `merchant_service`.
    *   `backend/api_routers/gateway/router.py`:
        *   Эндпоинт `initialize_payin` (например, `POST /gateway/payin/initiate_session`): Принимает данные для инициации платежа от мерчанта. Вызывает `gateway_service.initialize_payin_session` и возвращает мерчанту уникальный URL для редиректа клиента на страницу оплаты (например, `{"payment_url": "https://pay.yourdomain.com/{token}"}`).
        *   Эндпоинт для получения деталей сессии оплаты (например, `GET /gateway/payment_session/{token}`): Может использоваться самой страницей оплаты для получения данных о заказе. Вызывает `gateway_service.get_payment_session_details_by_token`.
        *   Эндпоинт для подтверждения со страницы оплаты (например, `POST /gateway/payment_session/{token}/confirm`): Принимает подтверждение и данные чека (если применимо) со страницы оплаты. Вызывает `gateway_service.handle_payment_page_confirmation`. Этот эндпоинт не предназначен для прямого вызова мерчантом или конечным клиентом.
        *   Эндпоинты `get_payin_status`, `initialize_payout`, `get_payout_status` остаются для использования мерчантами.
        *   Старый эндпоинт `confirm_payin_payment` (прямая загрузка чека клиентом) заменяется новой логикой взаимодействия через уникальную страницу оплаты.
*   **Исключения:** Роутеры могут содержать минимальную логику, специфичную для HTTP (например, обработка `FileUpload` на эндпоинте подтверждения со страницы оплаты) перед передачей данных в сервис.

Эта практика улучшает разделение ответственности, тестируемость и переиспользование бизнес-логики.

---

## 6. Дополнительные Компоненты и Утилиты

### 6.1. Утилиты для Запросов (`utils/query_utils.py`)
*   Функции для применения пагинации, сортировки, фильтров по датам и статусам к запросам SQLAlchemy.

### 6.2. Утилиты для Фильтров Запросов (`utils/query_filters.py`)
*   `get_active_trader_filters()`: Возвращает набор фильтров SQLAlchemy для выборки активных и работоспособных трейдеров.
*   `get_active_requisite_filters()`: Аналогично для реквизитов (учитывая статус `approve` и флаги `pay_in`/`pay_out` в `FullRequisitesSettings`).
Эти функции используются в `requisite_selector`, `trader_service`, `teamlead_service` для консистентной выборки.

### 6.3. Управление Конфигурацией из БД (`utils/config_loader.py`)
*   Загрузка типизированных значений из таблицы `ConfigurationSetting`.
*   Реализованы синхронные (`get_config_value`, `get_typed_config_value`) и асинхронные (`get_config_value_async`, `get_typed_config_value_async`) версии функций.
*   Поддерживает кэширование с использованием `cachetools.TTLCache` для синхронных вызовов и `asyncache` (с `AsyncTTLCache`) для асинхронных.

### 6.4. Клиент S3 (`utils/s3_client.py`)
*   Асинхронные функции для загрузки и получения файлов из S3-совместимого хранилища. Основная функция для загрузки - `upload_fileobj_async`.

---

## 7. Тестирование (Общие Аспекты)

*   Для проверки корректности реализации гранулярных прав (особенно `permission_service._match_permission`) требуются исчерпывающие юнит-тесты.
*   Компоненты с высокой цикломатической сложностью или критически важной логикой (например, `order_processor`, `requisite_selector`) должны иметь высокий уровень покрытия тестами.

---

## 8. Дальнейшие Шаги и Потенциальные Улучшения

*   Рассмотреть необходимость реализации задачи `poll_new_orders_task` в `backend/worker/tasks.py`.
*   Уточнить требования к rate limiting для API поддержки и тимлидов и, при необходимости, реализовать.
*   Провести ревью и, возможно, унифицировать структуру роутеров в `merchant/server.py` и `trader/server.py`.
*   Рассмотреть более гранулярное управление лимитами API через БД в `middleware/rate_limiting.py`.
*   Обеспечить полное покрытие логгером `get_logger` всех модулей, включая оставшиеся скрипты.
*   Продолжать работу над увеличением тестового покрытия.

Этот документ будет обновляться по мере развития бэкенд-системы JivaPay.

# Документация по бэкенду JivaPay

## Архитектура

JivaPay использует асинхронную архитектуру для обеспечения высокой производительности и масштабируемости.

### Основные компоненты

1. **API Серверы**
   - FastAPI с асинхронной поддержкой
   - Многопроцессорная обработка (workers)
   - Асинхронные эндпоинты

2. **База данных**
   - PostgreSQL с асинхронным драйвером asyncpg
   - SQLAlchemy 2.0+ с асинхронной поддержкой
   - Оптимизированный пул соединений

3. **Сервисы**
   - Асинхронная бизнес-логика
   - Изолированные контексты выполнения
   - Обработка ошибок и транзакций

## Структура проекта

```
backend/
├── api_routers/          # Асинхронные маршруты API
│   ├── admin/           # Административные эндпоинты
│   ├── merchant/        # API для мерчантов
│   ├── trader/          # API для трейдеров
│   └── gateway/         # Платежный шлюз
├── database/            # Работа с базой данных
│   ├── engine.py       # Асинхронный движок
│   ├── utils.py        # Асинхронные утилиты
│   └── db.py           # Модели данных
├── services/           # Бизнес-логика
│   ├── merchant/       # Сервисы для мерчантов
│   ├── trader/         # Сервисы для трейдеров
│   └── payment/        # Платежные сервисы
└── utils/              # Общие утилиты
```

## Асинхронная обработка

### API Эндпоинты

```python
@router.get("/items/{item_id}")
async def get_item(item_id: int, db: AsyncSession = Depends(get_db_session)):
    return await item_service.get_item(db, item_id)
```

### Сервисы

```python
class ItemService:
    async def get_item(self, db: AsyncSession, item_id: int):
        async with atomic_transaction(db) as transaction:
            return await get_object_or_none(db, Item, id=item_id)
```

### Транзакции

```python
async with atomic_transaction(db_session) as transaction:
    # Асинхронные операции
    await create_object(db_session, model, data)
    await update_object_db(db_session, obj, new_data)
```

## Оптимизация производительности

1. **Многопроцессорная обработка**
   - Использование workers в uvicorn
   - Балансировка нагрузки
   - Изоляция процессов

2. **Пул соединений**
   - Оптимальный размер пула
   - Таймауты и переподключения
   - Мониторинг состояния

3. **Кэширование**
   - Redis для кэширования
   - Инвалидация кэша
   - Стратегии кэширования

## Безопасность

1. **Аутентификация**
   - JWT токены
   - Асинхронная валидация
   - Защита от атак

2. **Авторизация**
   - Ролевая модель
   - Проверка прав
   - Аудит действий

3. **Защита данных**
   - Шифрование
   - Безопасные соединения
   - Валидация входных данных

## Мониторинг и логирование

1. **Метрики**
   - Prometheus для сбора метрик
   - Grafana для визуализации
   - Алерты и уведомления

2. **Логирование**
   - Структурированные логи
   - Уровни логирования
   - Ротация логов

## Развертывание

1. **Docker**
   - Многоконтейнерная архитектура
   - Оптимизированные образы
   - Управление конфигурацией

2. **Оркестрация**
   - Docker Compose для разработки
   - Kubernetes для продакшена
   - Масштабирование сервисов

## Рекомендации по разработке

1. **Асинхронное программирование**
   - Используйте async/await
   - Избегайте блокирующих операций
   - Правильно обрабатывайте ошибки

2. **Тестирование**
   - Асинхронные тесты
   - Моки и стабы
   - Интеграционные тесты

3. **Документация**
   - OpenAPI спецификация
   - Документация кода
   - Примеры использования 