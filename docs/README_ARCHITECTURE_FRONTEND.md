# Архитектура фронтенда JivaPay

В этом документе мы расскажем, как устроен фронтенд JivaPay. Мы используем TypeScript и создаем отдельные приложения для разных ролей пользователей.

## Основные принципы

- **Отдельные приложения** для каждой роли (мерчант, трейдер, админ, саппорт) — это упрощает разработку и позволяет независимо масштабировать каждое приложение
- **TypeScript** для надежности кода и удобной разработки
- **Компонентный подход** — разбиваем интерфейс на переиспользуемые части
- **Генерация типов** из OpenAPI для синхронизации с бэкендом
- **Эффективная работа с данными** — серверная пагинация, кэширование, обновления в реальном времени
- **Безопасность** — правильное хранение токенов, защита от XSS, маскирование чувствительных данных
- **Продуманное управление UI/UX и анимациями:** Акцент на использовании нативных возможностей браузера и, при необходимости, легковесных библиотек для гибкой настройки визуальных эффектов и обеспечения высокой производительности. Это позволяет создавать филигранные анимации для мельчайших элементов интерфейса без перегрузки кода.
    - **Приоритетные технологии:**
        - **CSS Transitions:** Для простых анимаций состояний (hover, focus, active), изменений свойств по одному триггеру.
        - **CSS Animations (`@keyframes`):** Для более сложных, циклических или многошаговых анимаций, не требующих прямого контроля из JavaScript во время выполнения.
        - **Web Animations API (WAAPI):** Для анимаций, требующих динамического контроля из JavaScript (пауза, воспроизведение, изменение скорости, таймлайны) или для создания сложных последовательностей.
    - **Структура и организация кода:**
        - **Локальные анимации:** Определяются в стилях конкретного компонента.
        - **Общие/переиспользуемые анимации:**
            - В каждом приложении создается директория `src/animations/` для CSS `@keyframes`, JavaScript-функций/хуков с WAAPI (например, `useFadeIn`), и конфигураций анимаций.
            - В общем пакете `ui-kit` или новом `packages/animations` могут размещаться универсальные анимационные утилиты.
        - **CSS Custom Properties:** Активное использование для параметров анимаций (длительность, задержка, функция плавности) для легкой настройки, темизации и контроля из JavaScript.
    - **Подход к созданию:**
        - **Производительность:** Анимировать преимущественно `transform` и `opacity`. Использовать `will-change` осмысленно.
        - **Минимализм:** Избегать тяжелых внешних библиотек, если задача решается нативными средствами. При необходимости – выбирать легковесные решения с tree-shaking.
        - **Доступность:** Учитывать `prefers-reduced-motion` для возможности отключения/уменьшения анимаций.
        - **UX-ориентированность:** Анимации должны улучшать опыт, направлять внимание и давать обратную связь.
        - **Инструменты:** Использование браузерных инструментов разработчика для анализа и отладки анимаций.

## Структура проекта

Каждое приложение (`merchant_app`, `trader_app` и т.д.) имеет такую структуру:

```
src/
  assets/       # Статические ассеты специфичные для приложения: изображения (SVG, PNG, JPG), шрифты, иконки, которые не являются частью общего ui-kit.

  components/    # Переиспользуемые UI-компоненты, специфичные для данного приложения. 
                 # Делятся на:
                 #  - ui/: Мелкие, атомарные компоненты (кнопки, инпуты, чекбоксы), если они кастомизированы для приложения и отличаются от ui-kit.
                 #  - features/: Более крупные компоненты, реализующие какую-то бизнес-логику или её часть (например, форма логина, карточка пользователя, список транзакций с фильтрами).
                 #  - widgets/: Составные блоки интерфейса, которые могут включать в себя features и ui компоненты, образуя самостоятельные секции (например, сайдбар, хедер специфичный для приложения).

  app/          # (Для приложений на Next.js с App Router, заменяет pages/) Директория для определения маршрутов и компонентов страниц.
                 # Каждая поддиректория в app/ соответствует сегменту URL. Файл page.tsx (или .js) в такой директории
                 # является React компонентом, отображаемым для данного маршрута.
                 # Например, app/dashboard/page.tsx будет страницей для /dashboard.
                 # Здесь же размещаются layout.tsx для определения общих макетов для сегментов маршрутов.
                 # Собираются из layouts, widgets, features и ui-компонентов.
                 # Может содержать логику загрузки данных, специфичную для страницы (например, через Server Components).

  layouts/      # Компоненты, определяющие общую структуру (обертку) для страниц приложения. 
                 # Например, `MainLayout` (с хедером, футером, сайдбаром), `AuthLayout` (для страниц логина/регистрации). 
                 # Позволяют избежать дублирования разметки на разных страницах.

  services/     # Модули для взаимодействия с API и другими внешними сервисами.
                 #  - api/: Инстансы Axios/fetch, функции для отправки запросов к бэкенду, сгруппированные по ресурсам (например, `authService.ts`, `userService.ts`).
                 #  - sse/: Логика для работы с Server-Side Events, если используется для обновлений в реальном времени.
                 #  - websocket/: Логика для работы с WebSockets, если используется.

  hooks/        # Кастомные React хуки, специфичные для данного приложения, для переиспользования логики состояния и побочных эффектов между компонентами.
                 # Например, `useFormValidation`, `useDebounce`, `useAuth`.

  animations/   # Специфичные для приложения анимации, хуки и утилиты.
                 #  - keyframes/: CSS `@keyframes` для анимаций.
                 #  - hooks/: Хуки для управления анимациями (например, `usePageTransition`).
                 #  - utils/: Вспомогательные функции для работы с Web Animations API.
                 #  - config/: Общие параметры анимаций (длительности, функции плавности).

  store/        # Глобальное состояние приложения, если оно достаточно сложное и не покрывается React Context. 
                 # Предпочтение легковесным библиотекам (Zustand, Jotai). 
                 # Структура внутри может быть по модулям/срезам (slices), соответствующим бизнес-сущностям.

  contexts/     # React контексты для управления состоянием, которое должно быть доступно в определенной части дерева компонентов, 
                 # но не является глобальным для всего приложения. Также для Dependency Injection.
                 # Например, `ThemeContext`, `NotificationsContext`.

  types/        # TypeScript интерфейсы, типы и enums, специфичные для данного приложения. 
                 #  - entities/: Типы, описывающие основные бизнес-сущности приложения.
                 #  - api/: Типы для запросов и ответов API, если они не генерируются из OpenAPI или требуют доработки.
                 #  - DTOs, генерируемые из OpenAPI, также могут располагаться здесь или в отдельной поддиректории.

  utils/        # Вспомогательные функции и утилиты, специфичные для приложения, не являющиеся хуками или сервисами.
                 # Например, функции форматирования дат, валидаторы, хелперы для работы с localStorage.

  locales/      # Файлы переводов (i18n) в формате JSON, специфичные для данного приложения (например, en.json, ru.json).
                 # Загружаются вместе с общими переводами из packages/i18n.

  styles/       # **Ключевое место для кастомизации общего `ui-kit` и определения специфичных для приложения стилей.**
                 #  - `global.css/scss`: Общие стили, сбросы, шрифты, применение темы.
                 #  - `theme.ts/js` (или `variables.css/scss`): Определение/переопределение значений CSS Custom Properties из `ui-kit` для настройки цветовой схемы, типографики и других визуальных аспектов общих компонентов под нужды приложения.
                 #  - `overrides/`: CSS-файлы для точечного и более глубокого переопределения стилей компонентов из `ui-kit`, если темизации через переменные недостаточно.
                 #  - Дополнительные CSS-модули или файлы для стилизации компонентов, страниц и виджетов, специфичных только для данного приложения.
```

## Приложения

### Приложение мерчанта
- **Главная задача:** Управление магазинами и отслеживание платежей
- **Основные страницы:**
  - Дашборд с балансами и статистикой
  - Список магазинов с настройками
  - История ордеров
  - Настройки профиля
  - Документация по API

### Приложение трейдера
- **Главная задача:** Управление реквизитами и обработка ордеров
- **Основные страницы:**
  - Дашборд с балансами
  - Управление реквизитами
  - Назначенные ордера
  - История балансов
  - Настройки профиля

### Приложение администратора
- **Главная задача:** Полный контроль над системой
- **Основные страницы:**
  - Дашборд со статистикой
  - Управление пользователями
  - Управление реквизитами
  - Системные настройки
  - Логи и мониторинг

### Приложение саппорта
- **Главная задача:** Помощь пользователям
- **Основные страницы:**
  - Универсальный поиск
  - Просмотр ордеров
  - Просмотр пользователей
  - Настройки профиля

### Приложение тимлида
- **Главная задача:** Управление командой трейдеров
- **Основные страницы:**
  - Статистика команды
  - Управление трейдерами
  - Просмотр реквизитов
  - Настройки профиля

## Общие компоненты и утилиты

Для переиспользования кода между различными фронтенд-приложениями, общие пакеты (такие как `ui-kit`, `types`, `utils`, `hooks`, `config`, `i18n`) размещаются в директории `frontend/packages/`. К таким пакетам относятся:

- `ui-kit` — **Основа общего пользовательского интерфейса** для всех приложений. Содержит базовый набор компонентов (кнопки, инпуты, модальные окна, таблицы, элементы навигации и т.д.) с единым дизайном и поведением. Компоненты `ui-kit` разрабатываются с учетом возможности их **темизации** и **кастомизации** через:
    - **CSS Custom Properties (переменные):** Ключевые параметры стиля (цвета, шрифты, отступы, размеры, тени) задаются через CSS переменные.
    - **Пропсы для настройки:** Компоненты могут принимать пропсы для изменения поведения или аспектов внешнего вида, не покрываемых CSS переменными.
    - **Четко определенные CSS классы/атрибуты:** Для возможности точечного переопределения стилей на уровне приложения.
- `types` — общие типы TypeScript
- `utils` — вспомогательные функции
- `hooks` — переиспользуемые хуки
- `config` — общие настройки
- `i18n` — переводы

### Стратегия темизации и кастомизации UI

Для обеспечения единого визуального стиля во всех приложениях с возможностью индивидуальной адаптации используется следующая стратегия:

1.  **Базовый стиль и темизация в `ui-kit`:**
    *   Все компоненты в `ui-kit` стилизуются с использованием CSS Custom Properties для основных параметров дизайна (цветовая палитра, типографика, отступы, скругления углов и т.д.).
    *   `ui-kit` может предоставлять одну или несколько предустановленных тем (например, светлая, темная), которые приложения могут использовать напрямую.

2.  **Кастомизация на уровне приложения (в `src/styles/`):**
    *   Каждое приложение (`merchant_app`, `trader_app` и т.д.) имеет собственную директорию `src/styles/`.
    *   **`src/styles/theme.ts/js` (или `variables.css/scss`):** В этом файле приложение определяет или переопределяет значения CSS Custom Properties, предоставляемых `ui-kit`. Это позволяет настроить цветовую схему, шрифты и другие визуальные аспекты общих компонентов в соответствии с уникальными требованиями или брендингом конкретного приложения, сохраняя при этом общую структуру и поведение компонентов из `ui-kit`.
    *   **`src/styles/overrides/`:** Если для кастомизации компонента из `ui-kit` недостаточно изменения CSS переменных (например, нужно изменить его внутреннюю структуру, добавить специфические анимации или состояния), в этой поддиректории размещаются CSS-файлы, которые точечно переопределяют или дополняют стили конкретных общих компонентов. Эти переопределения применяются только в рамках данного приложения.
    *   **`src/styles/global.css/scss`:** Может содержать общие для приложения стили, сбросы, а также импортировать и применять выбранную тему (переопределенные CSS переменные).

3.  **Принцип наследования и специфичности:**
    *   Стили `ui-kit` служат основой.
    *   Стили приложения (определения переменных темы и переопределения) имеют более высокий приоритет и позволяют адаптировать внешний вид.
    *   Такой подход обеспечивает баланс между общностью UI/UX и гибкостью кастомизации для каждого отдельного приложения.

## Интернационализация (i18n)

Для поддержки мультиязычности во всех приложениях будет использоваться следующая стратегия:

1.  **Библиотека и инструменты:**
    *   Рекомендуется использовать библиотеку `i18next` совместно с `react-i18next` для интеграции с React.
    *   Это обеспечит гибкое управление переводами, определение языка, форматирование и другие возможности i18n.

2.  **Файлы переводов:**
    *   Переводы будут храниться в JSON файлах.
    *   Для каждого поддерживаемого языка создается отдельный файл (например, `en.json`, `ru.json`).
    *   Ключи переводов могут быть вложенными для лучшей организации (например, `common.submit`, `userProfile.title`).

3.  **Разделение переводов:**
    *   **Общие переводы:** Строки, используемые в нескольких приложениях или в компонентах из `ui-kit`, размещаются в общем пакете `frontend/packages/i18n/src/locales/`.
    *   **Специфичные для приложения переводы:** Строки, уникальные для конкретного приложения, размещаются в директории `src/locales/` внутри каждого приложения. Приложение будет загружать как общие переводы, так и свои специфичные, при этом специфичные могут переопределять общие при совпадении ключей.

4.  **Загрузка и использование:**
    *   Конфигурация `i18next` будет производиться при инициализации каждого приложения, объединяя общие и специфичные для приложения ресурсы переводов.
    *   Переводы могут загружаться асинхронно для оптимизации начальной загрузки.
    *   В компонентах для доступа к переводам будет использоваться хук `useTranslation()` из `react-i18next`.

5.  **Определение языка:**
    *   Язык пользователя может определяться на основе:
        *   Настроек пользователя в приложении (сохраненных, например, в localStorage).
        *   Параметра в URL.
        *   Языка браузера (с возможностью выбора для пользователя).
        *   Значения по умолчанию, заданного в конфигурации.

6.  **Форматирование и Плюрализация:**
    *   `i18next` предоставляет встроенные возможности для форматирования дат, чисел и обработки форм множественного числа (плюрализации) в соответствии с правилами выбранного языка.

7.  **Процесс добавления переводов:**
    *   Новые строки для перевода добавляются в соответствующие JSON файлы (общие или специфичные для приложения).
    *   Рекомендуется использовать четкие, осмысленные и, по возможности, структурированные ключи.
    *   Для упрощения управления переводами и проверки их полноты можно рассмотреть использование специализированных инструментов или написание скриптов.

## Тестирование

- **Unit-тесты** для функций и хуков
- **Компонентные тесты** для UI
- **Интеграционные тесты** для проверки взаимодействия компонентов
- **E2E тесты** для проверки полных сценариев

## Развертывание

- Каждое приложение размещается на своем поддомене
- Используем CI/CD для автоматизации сборки и деплоя
- Настроена защита от DDoS и rate limiting

## Платежный шлюз

Предоставляем два варианта интеграции:

1. **Хостируемая страница оплаты**
   - Простая интеграция для мерчанта
   - Полный контроль над UI/UX
   - Безопасность на нашей стороне

2. **Платежный виджет**
   - Встраивается на сайт мерчанта
   - Более бесшовный опыт для клиента
   - Требует более сложной интеграции

## Следующие шаги

1. Выбрать стек технологий и UI библиотеку
2. Настроить монорепозиторий и CI/CD
3. Настроить генерацию типов
4. Реализовать базовые компоненты
5. Разработать функционал по ролям
6. Добавить SSE для обновлений в реальном времени
7. Проверить безопасность и доступность
8. Провести UI/UX ревью 