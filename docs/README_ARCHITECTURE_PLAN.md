# План Архитектуры и Базовой Структуры Frontend (TypeScript - Мульти-приложение) - Детализированный

---

## 1. Введение

Этот документ описывает **детализированный** план создания базовой структуры фронтенд-приложений на **TypeScript** для различных ролей пользователей (Мерчант, Трейдер, Админ, Саппорт) системы JivaPay. План основан на бэкенд-архитектуре и документации (`backend/*`), а также учитывает существующую **мульти-аппликационную структуру** директории `frontend/`.

**Цель:** Заложить надежный, масштабируемый и удобный в поддержке фундамент для разработки пользовательских интерфейсов каждой роли, обеспечив при этом консистентность и эффективное переиспользование кода.

**Ключевые Принципы:**

*   **Раздельные SPA:** Каждая роль получает свое независимое приложение. Это упрощает разработку и развертывание специфичного для роли функционала, предотвращает разрастание единой кодовой базы и позволяет независимо масштабировать команды или технологии для разных приложений при необходимости.
*   **TypeScript:** Строгая типизация повышает надежность кода, облегчает рефакторинг, улучшает автодополнение в IDE и помогает ловить ошибки на этапе компиляции, что критически важно для финансовых приложений.
*   **Компонентный подход:** Разбиение интерфейса на переиспользуемые компоненты (кнопки, таблицы, формы, специфичные виджеты) ускоряет разработку, упрощает тестирование и обеспечивает единообразие UI.
*   **Генерация Типов из OpenAPI:** Использование генераторов (например, `openapi-typescript-codegen`) для создания TypeScript-типов на основе OpenAPI спецификации бэкенда **настоятельно рекомендуется**. Это гарантирует синхронизацию моделей данных между фронтендом и бэкендом, минимизируя ошибки интеграции.
*   **Эффективная работа с данными:** Применение серверной пагинации, сортировки и фильтрации для больших списков (ордера, пользователи) предотвращает передачу и обработку избыточных данных на клиенте. Использование библиотек управления серверным состоянием (React Query, RTK Query) оптимизирует кэширование и обновление данных.
*   **Обновления в реальном времени (SSE):** Server-Sent Events используются для немедленного отображения критически важных изменений (статусы ордеров, новые назначения) без необходимости пользователю обновлять страницу или постоянного поллинга, улучшая UX и снижая нагрузку.
*   **Продуманная Обработка Ошибок:** Четкое разделение и обработка ошибок API (сетевые, серверные 5xx, клиентские 4xx) и внутренних ошибок фронтенда (ошибки рендеринга, состояния). Интеграция с системами мониторинга (Sentry) для быстрого обнаружения и исправления проблем.
*   **Консистентность UI/UX:** Достигается за счет использования общих UI-компонентов, единой дизайн-системы (темы) и гайдлайнов, особенно при использовании стратегии с общими пакетами.
*   **Оптимизация загрузки (Lazy Loading):** Маршруты и тяжелые компоненты подгружаются по мере необходимости, улучшая время первоначальной загрузки приложения (TТI).
*   **Доступность (a11y):** При разработке компонентов и страниц учитываются стандарты WCAG для обеспечения возможности использования приложений людьми с ограниченными возможностями.
*   **Интернационализация (i18n):** Архитектура должна быть готова к поддержке нескольких языков, даже если это не требуется на первом этапе. Использование библиотек типа `i18next` и вынесение строк в файлы переводов.
*   **Безопасность:** Надлежащее управление токенами аутентификации (хранение, передача), избегание хранения чувствительной информации в `localStorage`, маскирование данных (API-ключи, номера реквизитов), защита от XSS (в основном обеспечивается фреймворком, но требует внимания при использовании `dangerouslySetInnerHTML`).
*   **Защита от DDoS:** Внедрение многоуровневой защиты от распределенных атак типа "отказ в обслуживании" (DDoS) **на уровне инфраструктуры**. Это включает использование специализированных сервисов (например, CDN с функцией защиты, WAF - Web Application Firewall, облачные сервисы типа AWS Shield/Azure DDoS Protection/Google Cloud Armor) для фильтрации и блокировки вредоносного трафика еще до того, как он достигнет серверов приложений. Эта защита нацелена на все внешние запросы к публичным доменам приложений (`merchant.jivapay.com`, `trader.jivapay.com` и т.д.). В качестве дополнения, на стороне бэкенда реализовано ограничение частоты запросов через slowapi+Redis с динамической загрузкой лимитов из БД (ключ `RATE_LIMIT_DEFAULT`) через контекст-менеджер `get_db_session_cm()`).

---

## 2. Базовая Структура Директорий

*Мульти-аппликационная структура (`merchant_app`, `trader_app` и т.д.) сохраняется. Внутри каждого приложения `src/` будет содержать стандартные поддиректории:* 
    *   `components`: Переиспользуемые React-компоненты.
    *   `pages`: Компоненты верхнего уровня, соответствующие маршрутам приложения.
    *   `layouts`: Компоненты-обертки для страниц (например, с сайдбаром и хедером).
    *   `services`: Модули для взаимодействия с внешним миром (API, SSE).
    *   `hooks`: Кастомные React-хуки для инкапсуляции логики.
    *   `store`: Глобальное состояние приложения (если используется).
    *   `contexts`: React Contexts для проброса данных.
    *   `types`: Определения TypeScript типов/интерфейсов (или импорт из общего пакета).
    *   `utils`: Вспомогательные функции.
    *   `assets`: Статические файлы.
    *   `styles`: Глобальные стили, темы.
*При использовании монорепозитория рекомендуется настройка единых правил форматирования/линтеров (ESLint, Prettier) и общей базовой конфигурации TypeScript (`tsconfig.base.json`) для всех приложений и пакетов.* 

--- 

## 3. Детализированный План Реализации по Ролям (внутри каждого приложения)

Общие шаги для **каждого** приложения:

*   **Настройка проекта:** Инициализация с помощью Vite или CRA, установка зависимостей, настройка TypeScript.
*   **Маршрутизация:** Настройка React Router для навигации внутри приложения.
*   **Аутентификация:** Реализация страницы логина, API запроса для получения токена, безопасного хранения токена (например, в памяти с обновлением через refresh-токены или в `HttpOnly` cookie, если позволяет бэкенд) и механизма защиты маршрутов.
*   **Layout:** Создание основного `AuthenticatedLayout` с навигацией (сайдбар/меню) и хедером.
*   **Управление состоянием:**
    *   **Серверное:** Настройка React Query/RTK Query. Определение базовых запросов и мутаций с использованием типизированных функций из `services/*.ts`.
    *   **UI:** Выбор подхода (Context/Zustand/...) и реализация для необходимого UI-состояния (например, состояние фильтров, открытых модалок).
*   **API Клиент:** Настройка `axios` или `fetch` с интерцепторами для добавления токена авторизации и централизованной обработки ошибок API.
*   **Типизация:** Настройка генерации типов из OpenAPI или создание/импорт базовых типов.
*   **SSE:** Реализация сервиса или хука для установки и управления SSE-соединением, обработки сообщений.
*   **Обработка ошибок:** Настройка Sentry SDK (или аналога) и глобального обработчика ошибок React (Error Boundary).

*(Далее идет детализация для каждой роли, как в предыдущей версии, но с пониманием, что она реализуется в контексте своего приложения и использует описанные выше общие подходы)*

### 3.1. Приложение Мерчанта (`frontend/merchant_app/`)
*   **Ключевая задача:** Предоставить удобный интерфейс для управления магазинами, отслеживания финансовых потоков (балансы, ордера) и получения необходимой информации для интеграции (API ключи, документация).
*   **Детализация страниц:**
    *   `pages/Dashboard.tsx`: Отображение текущих балансов (`BalanceStore[]`), статусов магазинов, виджет с недавними ордерами (`IncomingOrder`/`OrderHistory`), ключевые KPI (если применимо).
    *   `pages/Stores.tsx`: Таблица со списком магазинов мерчанта (`MerchantStore[]`). Возможность просмотра деталей, управления статусами (`is_active`), лимитами (`limits`), настройками коллбэков. **Безопасное** управление API ключами (генерация/просмотр ID/обновление секрета без повторного показа секрета).
    *   `pages/StoreCreate.tsx` / `pages/StoreEdit.tsx`: Формы для создания/редактирования магазина.
    *   `pages/Orders.tsx`: Таблица с историей ордеров (`IncomingOrder[]`, `OrderHistory[]`), включая фильтры (по дате, статусу, магазину), пагинацию. Обновление статусов через SSE.
    *   `pages/ProfileSettings.tsx`: Настройки профиля пользователя-мерчанта.
    *   `pages/ApiDocs.tsx`: (Возможно) Встроенная или ссылка на документацию по API для интеграции.
*   **API/SSE/Типы:** Использование типизированных запросов к эндпоинтам `/api/merchant/*`, обработка SSE-сообщений для ордеров.

### 3.2. Приложение Трейдера (`frontend/trader_app/`)
*   **Ключевая задача:** Обеспечить эффективное управление реквизитами и их настройками, оперативное получение информации о новых назначенных ордерах (через SSE) и отслеживание истории балансов.
*   **Детализация страниц:**
    *   `pages/Dashboard.tsx`: Отображение текущих балансов (`BalanceTrader[]`), статуса работы (`is_active`), количества активных/назначенных ордеров, KPI производительности.
    *   `pages/Requisites.tsx`: Таблица со списком реквизитов трейдера (`ReqTrader[]`) с их статусами (`status`). Форма добавления нового реквизита. Модальные окна для редактирования настроек (`FullRequisitesSettings`, включая лимиты, валюты, время работы).
    *   `pages/AssignedOrders.tsx`: Таблица с назначенными ордерами (`OrderHistory[]`), требующими обработки. Обновления через SSE при назначении нового ордера. Механизм подтверждения/обработки ордера (уточнить логику).
    *   `pages/BalanceHistory.tsx`: Раздельные таблицы или вкладки для истории фиатных (`BalanceTraderFiatHistory[]`) и крипто (`BalanceTraderCryptoHistory[]`) балансов с фильтрами.
    *   `pages/ProfileSettings.tsx`: Настройки профиля пользователя-трейдера.
*   **API/SSE/Типы:** Использование типизированных запросов к `/api/trader/*`, обработка SSE для новых ордеров.

### 3.3. Приложение Администратора (`frontend/admin_app/`)
*   **Ключевая задача:** Предоставить полный контроль над системой: управление пользователями всех ролей (с учетом гранулярных прав), магазинами, реквизитами (включая модерацию), просмотр всех ордеров, настройка системных параметров и справочников.
*   **Детализация страниц (дополняется на основе требований из `docs/ADDITIONAL_FEATURES_AND_COMPONENTS.md` и новой системы прав):**
    *   `pages/Dashboard.tsx`: Агрегированная статистика.
        *   **Виджеты (доступ к каждому виджету определяется правом администратора, например `platform:view:balance`, `orders:view:count_total`, etc.):**
            *   "Баланс площадки" (компонент `PlatformBalanceWidget`): Отображение общего баланса платформы по различным валютам. Запрос к `GET /api/admin/platform/balance` (Ответ: `PlatformBalanceResponseSchema`).
            *   "История ордеров" (компонент `OrdersHistoryWidget` или ссылка на `pages/OrdersHistory.tsx`): Краткая статистика или последние ордера.
            *   "Количество реквизитов онлайн" (компонент `OnlineRequisitesWidget`): Отображение количества активных реквизитов в реальном времени. Использует SSE с `GET /api/admin/requisites/online-stats/stream`. Таблица с реквизитами при клике или на отдельной странице. Опции сортировки и фильтрации. (Бэкенд использует `query_utils.py` и `query_filters.py` для этой логики).
            *   "Количество трейдеров" (компонент `TradersStatsWidget`): Статистика по трейдерам. (Бэкенд использует `query_utils.py`).
            *   "Количество мерчантов и их магазинов" (компонент `MerchantsStatsWidget`): Статистика по мерчантам. (Бэкенд использует `query_utils.py`).
            *   "Общее количество ордеров" (компонент `TotalOrdersWidget`): Отображение общего количества ордеров. Фильтры по статусам, дате/времени. (Бэкенд использует `query_utils.py`).
            *   "Количество администраторов" (компонент `AdminsStatsWidget`): Статистика по администраторам. (Бэкенд использует `query_utils.py`).
            *   "Количество тимлидов" (компонент `TeamLeadsStatsWidget`): Статистика по тимлидам. (Бэкенд использует `query_utils.py`).
            *   "Количество саппортов" (компонент `SupportsStatsWidget`): Статистика по саппортам. (Бэкенд использует `query_utils.py`).
    *   `pages/OrdersHistory.tsx`: Таблица с историей всех ордеров.
        *   **Компоненты:** Таблица (`SharedTableComponent`), фильтры (`DateRangePicker`, `StatusSelect`, `TextField` для ID, email, etc.), пагинация.
        *   **Функционал:** Просмотр деталей ордера. Фильтрация по дате/времени, статусу, сумме, ID трейдера/магазина, части реквизита, email трейдера/мерчанта, названию магазина. Данные из `GET /api/admin/orders` (Ответ: `OrderHistoryAdminResponseSchema`). Полнота отображаемых данных/фильтров зависит от прав администратора (проверяется `PermissionService` на бэкенде). Бэкенд использует `query_utils.py` для стандартизации запроса и ответа.
    *   `pages/RequisitesOnlineStats.tsx` (или как часть `pages/RequisitesManagement.tsx`): Статистика и список онлайн реквизитов.
        *   **Компоненты:** Таблица, фильтры (по трейдеру, методу, банку, типу pay_in/pay_out), сортировка (по лимитам, направлению).
        *   **Функционал:** Обновление данных через SSE (`GET /api/admin/requisites/online-stats/stream`). Отображение "онлайн" статуса (кабинет трейдера доступен, трафик включен, реквизит включен на pay_in/pay_out).
    *   `pages/Users/TradersList.tsx`: Список трейдеров.
        *   **Компоненты:** Таблица, фильтры (статус, онлайн/оффлайн, период оборота, валюта, метод, крипта), поиск (email, id, telegram, телефон), сортировка (оборот, кол-во реквизитов, дата регистрации, кол-во ордеров, статус кабинета), пагинация.
        *   **Функционал:** Данные из `GET /api/admin/traders/stats`. Действия: переход к деталям, блокировка/разблокировка (`POST /api/admin/traders/{trader_id}/block` / `unblock`), редактирование профиля, лимитов, трафика (через `TraderDetailsFull.tsx`).
    *   `pages/Users/TraderDetailsFull.tsx`: Полная информация о трейдере (профиль, реквизиты, балансы, ордера, история действий). Редактирование профиля (`PUT /api/admin/traders/{trader_id}`), лимитов (`PUT /api/admin/traders/{trader_id}/limits`), трафика (`PUT /api/admin/traders/{trader_id}/traffic`).
    *   `pages/Users/MerchantsList.tsx`: Список мерчантов и их магазинов. Аналогично `TradersList.tsx`. Данные из `GET /api/admin/merchants/stats`.
    *   `pages/Users/MerchantDetailsFull.tsx`: Полная информация о мерчанте и его магазинах.
    *   `pages/SystemSettings/CriticalErrorsLog.tsx`: Просмотр логов критических ошибок системы. Данные из `GET /api/admin/logs/critical-errors`. Фильтрация, пагинация.
    *   `pages/Users/AdminsList.tsx`: Список администраторов. Данные из `GET /api/admin/administrators/stats`. Фильтр "доступен/недоступен".
    *   `pages/Users/AdminDetails.tsx`: Просмотр информации о другом администраторе (`GET /api/admin/administrators/{admin_id}`). UI для редактирования профиля (`PUT /api/admin/administrators/{admin_id}`), изменения гранулярных прав (`PUT /api/admin/administrators/{admin_id}/permissions` - мультиселект или чекбоксы для прав), блокировки/разблокировки (`POST /api/admin/administrators/{admin_id}/block` / `unblock`). Форма для создания нового администратора (`POST /api/admin/administrators`).
    *   `pages/Users/TeamLeadsList.tsx`: Список тимлидов. Данные из `GET /api/admin/teamleads/stats`. Фильтр "активные/все".
    *   `pages/Users/TeamLeadDetailsFull.tsx`: Информация о тимлиде (`GET /api/admin/teamleads/{teamlead_id}`). Управление профилем, правами (`PUT /api/admin/teamleads/{teamlead_id}`, `PUT /api/admin/teamleads/{teamlead_id}/permissions`), блокировка/разблокировка. Просмотр команды и статистики. Форма для создания нового тимлида (`POST /api/admin/teamleads`).
    *   `pages/Users/SupportsList.tsx`: Список саппортов. Данные из `GET /api/admin/supports/stats`. Фильтры "активные/все", по роли (описанию).
    *   `pages/Users/SupportDetails.tsx`: Информация о саппорте (`GET /api/admin/supports/{support_id}`). Управление профилем (включая `role_description`), правами (`PUT /api/admin/supports/{support_id}`, `PUT /api/admin/supports/{support_id}/permissions`), блокировка/разблокировка. Форма для создания нового саппорта (`POST /api/admin/supports`).
    *   `pages/RequisitesManagement.tsx` (расширение `pages/Requisites.tsx`): Обзор **всех** реквизитов. Помимо просмотра (как в `RequisitesOnlineStats.tsx`), добавление функционала модерации: одобрение/отклонение новых реквизитов, изменение статуса существующих, редактирование настроек.
    *   `pages/SystemSettings/ReferenceData.tsx`: Интерфейс для управления системными справочниками.
    *   `pages/SystemSettings/SystemStatus.tsx`: Мониторинг состояния ключевых компонентов системы.
    *   `pages/ProfileSettings.tsx`: Настройки профиля администратора.
*   **API/SSE/Типы:** Использование типизированных запросов к `/api/admin/*`. Бэкенд будет проверять гранулярные права по токену пользователя. SSE для "Количества реквизитов онлайн".

### 3.4. Приложение Саппорта (`frontend/support_app/`)
*   **Ключевая задача:** Обеспечить быстрый поиск и просмотр информации по ордерам и пользователям в соответствии с выданными гранулярными правами (`Support.granted_permissions`). UI должен динамически адаптироваться (скрывать/показывать элементы) на основе этих прав, проверяемых `PermissionService` на бэкенде.
*   **Детализация страниц (функционал определяется списком прав из `Support.granted_permissions`):**
    *   `pages/Dashboard.tsx` / `pages/Search.tsx`: Основной инструмент - универсальный поиск.
        *   **Виджеты (отображаются если есть соответствующие права):**
            *   "История ордеров" (компонент `OrdersHistoryWidgetSupport`): Запрос к `GET /api/support/orders` (Ответ: `OrderHistoryAdminResponseSchema`). Бэкенд использует `query_utils.py`.
            *   "Количество реквизитов онлайн" (компонент `OnlineRequisitesWidgetSupport`): Запрос к `GET /api/support/requisites/online-stats` и SSE. Бэкенд использует `query_utils.py` и `query_filters.py`.
            *   "Количество трейдеров" (компонент `TradersStatsWidgetSupport`): Запрос к `GET /api/support/traders/stats`. Бэкенд использует `query_utils.py`.
    *   `pages/OrdersHistory.tsx`: Доступ к истории ордеров. Данные из `GET /api/support/orders`. Поля, фильтры и доступные ордера определяются правами. Бэкенд использует `query_utils.py`.
    *   `pages/RequisitesOnlineStats.tsx`: Просмотр статистики по онлайн реквизитам. Данные из `GET /api/support/requisites/online-stats`. Объем данных и фильтры зависят от прав.
    *   `pages/TradersStats.tsx`: Просмотр статистики по трейдерам. Данные из `GET /api/support/traders/stats`. Объем данных и фильтры зависят от прав.
    *   `pages/OrderDetailViewer.tsx`: Детальный просмотр ордера (`GET /api/support/orders/{order_id}`). Только чтение. Отображаемые поля зависят от прав.
    *   `pages/TraderDetailViewer.tsx`: Детальный просмотр трейдера (`GET /api/support/traders/{trader_id}`). Только чтение. Просмотр его реквизитов (`GET /api/support/traders/{trader_id}/requisites`), ордеров (`GET /api/support/traders/{trader_id}/orders`). Поиск трейдеров (`GET /api/support/traders/search?query={...}`).
    *   `pages/MerchantDetailViewer.tsx`: Детальный просмотр мерчанта (`GET /api/support/merchants/{merchant_id}`) и его магазинов (`GET /api/support/stores/{store_id}`). Поиск мерчантов (`GET /api/support/merchants/search?query={...}`).
    *   `pages/OrderActionModal.tsx`: Модальное окно для выполнения действий над ордерами (если есть права `orders:action:*`). Запрос к `POST /api/support/orders/{order_id}/action`.
    *   `pages/ProfileSettings.tsx`: Настройки профиля саппорта.
*   **API/Типы:** Использование типизированных запросов к `/api/support/*`. Бэкенд проверяет гранулярные права из `Support.granted_permissions`. UI должен скрывать/показывать элементы управления на основе этих прав.

### 3.5. Приложение Тимлида (`frontend/teamlead_app/`)
*   **Ключевая задача:** Тимлид отвечает за группу трейдеров. Функционал определяется гранулярными правами из `TeamLead.granted_permissions`, проверяемыми `PermissionService` на бэкенде.
*   **Детализация страниц (функционал определяется списком прав):**
    *   `pages/Dashboard.tsx`: Сводная статистика по своей команде.
        *   **Виджеты:**
            *   "Количество реквизитов онлайн (моя команда)" (компонент `TeamOnlineRequisitesWidget`): Данные из `GET /api/teamlead/requisites/online-stats` и SSE (`GET /api/teamlead/requisites/online-stats/stream`), автоматически отфильтрованные по трейдерам команды. Бэкенд использует `query_utils.py` и `query_filters.py` (учитывая `Trader.is_traffic_enabled_by_teamlead`).
            *   "Общая статистика команды" (компонент `TeamOverallStatsWidget`): Оборот, количество ордеров и т.д. из `GET /api/teamlead/my-team/stats`. Бэкенд может использовать `query_utils.py`.
    *   `pages/ManagedTraders.tsx`: Таблица трейдеров своей команды. Данные из `GET /api/teamlead/my-traders` (Ответ: `List[TeamLeadTraderBasicInfoSchema]`). Бэкенд может использовать `query_utils.py`.
    *   `pages/TraderDetails.tsx`: Отчёты по выбранному трейдеру из своей команды (`GET /api/teamlead/my-traders/{trader_id}`). Статистика по трейдеру (`GET /api/teamlead/my-traders/{trader_id}/statistics`).
    *   `pages/TeamRequisites.tsx`: Просмотр реквизитов своей команды. Данные из `GET /api/teamlead/my-traders/requisites` с фильтрами.
    *   `pages/ProfileSettings.tsx`: Настройки профиля тимлида.
*   **API/SSE/Типы:** Взаимодействие с `/api/teamlead/*`. Бэкенд проверяет права из `TeamLead.granted_permissions`. SSE для онлайн-реквизитов своей команды. UI должен адаптироваться к правам.

--- 

## 4. Общие Компоненты, Типы, Утилиты и Конфигурации

**Стратегии Переиспользования:**

1.  **Монорепозиторий с общими пакетами (Рекомендуется, с использованием PNPM Workspaces и Turborepo):**
    *   **Инструменты:** Рекомендуется использовать **PNPM** для управления зависимостями (эффективно работает с дисковым пространством и `node_modules`) и **Turborepo** для оркестрации задач (сборка, тестирование, линтинг) и их кэширования, что значительно ускоряет CI/CD и локальную разработку.
    *   **Преимущества:** Централизованное управление зависимостями, атомарные коммиты изменений в общем коде и его потребителях, упрощение рефакторинга, легкая локальная разработка и тестирование общих пакетов, оптимизированные скрипты и сборка.
    *   **Пакеты:**
        *   `packages/ui-kit`: Компоненты UI. **Важно:** Рекомендуется **на раннем этапе определиться с базовой UI библиотекой** (например, Material UI (MUI), Ant Design, Chakra UI, Headless UI + Tailwind CSS) или явно принять решение о разработке полностью кастомной библиотеки. Выбранная библиотека станет основой для `ui-kit`. `ui-kit` должен экспортировать не только обертки над базовыми компонентами (Button, Input, Table), но и кастомные, специфичные для домена компоненты (например, `OrderStatusBadge`, `RequisiteCard`), а также **общий провайдер темы** для гарантии визуальной консистентности во всех приложениях.
        *   `packages/types`: Генерируемые TypeScript типы. Централизация гарантирует консистентность.
        *   `packages/utils`: Функции, не имеющие зависимостей от UI или состояния конкретного приложения.
        *   `packages/hooks`: Переиспользуемые хуки (например, для работы с `localStorage`, форматирования, возможно, даже обертки над API, если структура запросов схожа).
        *   `packages/config`: Общие конфигурации ESLint, Prettier, TSConfig (`tsconfig.base.json`, от которого наследуются конфиги приложений).
        *   `packages/i18n`: Общие файлы переводов и конфигурация `i18next`.
2.  **Отдельные npm-пакеты:**
    *   **Преимущества:** Четкое версионирование общих частей, возможность использования разными командами/репозиториями.
    *   **Недостатки:** Сложнее управление зависимостями (проблемы версий), синхронизация изменений требует публикации и обновления во всех приложениях, усложнение локальной разработки.
3.  **Дублирование:**
    *   **Преимущества:** Простота на самом старте.
    *   **Недостатки:** Быстро приводит к рассинхронизации, увеличению трудозатрат на поддержку и исправление багов в одинаковом коде в разных местах. Не рекомендуется.

**Обработка Ошибок (Единый подход):**
*   **Цель:** Предоставить пользователю понятную обратную связь и собрать максимум информации для разработчиков.
*   **Реализация:** Централизованный обработчик в API-клиенте.
    *   **4xx ошибки (Bad Request, Unauthorized, Forbidden, Not Found...):** Часто требуют специфической обработки в UI (показать сообщение об ошибке валидации формы, перенаправить на логин, показать "не найдено"). Обработчик может пробрасывать типизированные ошибки дальше.
    *   **5xx ошибки (Internal Server Error...):** Обычно означают проблему на бэкенде. Следует показать пользователю общее сообщение ("Что-то пошло не так, попробуйте позже") и **обязательно** отправить детали ошибки в систему мониторинга (Sentry) с контекстом запроса.
*   **Sentry (или аналог):** Интеграция как для ошибок API (5xx), так и для неперехваченных ошибок JavaScript в самом фронтенд-приложении.

**Тестирование:**
*   **Unit-тесты (`jest`, `vitest`):** Проверка чистых функций (утилиты, редьюсеры), кастомных хуков. Быстрые и изолированные.
*   **Компонентные тесты (`testing-library`, Storybook/Ladle):** Тестирование UI-компонентов в изоляции, проверка рендеринга, взаимодействия, доступности. Visual regression тесты помогают отслеживать непреднамеренные визуальные изменения.
*   **Интеграционные тесты (`testing-library`):** Проверка взаимодействия нескольких компонентов или пользовательских сценариев в рамках *одного* приложения (например, заполнение формы и отправка запроса, рендеринг списка после загрузки данных).
*   **E2E тесты (`cypress`, `playwright`):** Тестирование полных пользовательских сценариев в браузере, включая взаимодействие с бэкендом. Дорогие в написании и поддержке, но дают наибольшую уверенность.

--- 

## 5. Сборка, Развертывание и Следующие Шаги

**Сборка и Развертывание:**
*   **Монорепо:** CI/CD пайплайн должен уметь определять измененные приложения/пакеты и запускать сборку/развертывание только для них.
*   **Хостинг:** Размещение на отдельных поддоменах (`merchant.jivapay.com`, `admin.jivapay.com`) часто предпочтительнее для изоляции и упрощения конфигурации CDN/кэширования, чем размещение на разных путях одного домена (`jivapay.com/merchant`).
*   **Окружения:** Наличие отдельных окружений для разработки, тестирования (staging) и продакшена с соответствующими `.env` файлами и настройками бэкенда.
*   **Инфраструктурная Безопасность:** Настройка и **обязательная** конфигурация выбранных средств защиты от DDoS (CDN/WAF/облачные сервисы) перед выводом приложений в продуктивное использование. Настройка правил Rate Limiting на уровне API Gateway или бэкенд-сервисов.

**Следующие Шаги:**
*(Шаги остаются прежними, но теперь с большим пониманием контекста)*
1.  Окончательный выбор стека (**включая базовую UI библиотеку**), стратегии переиспользования.
2.  Настройка инфраструктуры монорепозитория (если выбрано, **с использованием PNPM/Turborepo**) и **базового CI/CD**. 
    *   **CI/CD для Frontend:** Настроить пайплайн (GitHub Actions и т.п.) для запуска линтеров (ESLint, Prettier), проверки типов (TSC), юнит/компонентных тестов (Jest/Vitest/Testing Library) и сборки измененных приложений/пакетов (особенно важно для монорепозитория с Turborepo).
3.  Настройка генерации типов из OpenAPI и общих пакетов (`types`, `ui-kit`, `utils`, `hooks`, `config`, `i18n`).
4.  Реализация базовых слоев (аутентификация, layout, API-клиент, обработка ошибок, i18n) в каждом приложении или общих пакетах.
5.  Итеративная разработка функционала по ролям с написанием тестов.
6.  Интеграция SSE.
7.  Проверка доступности, безопасности.
8.  UI/UX ревью и полировка.

--- 

## 6. Платежный Шлюз (Frontend)

*   **Назначение:** Предоставить пользовательский интерфейс для конечных клиентов магазинов для проведения оплаты (Pay-In) или запроса выплаты (Pay-Out).
*   **Варианты реализации:**
    1.  **Хостируемая Страница Оплаты (Hosted Payment Page - HPP):**
        *   **Описание:** JivaPay хостит отдельную веб-страницу (или набор страниц), на которую мерчант перенаправляет своего клиента.
        *   **Плюсы:** Простая интеграция для мерчанта (только редирект с параметрами), полный контроль над UI/UX у JivaPay, проще обеспечить безопасность.
        *   **Минусы:** Менее бесшовный опыт для клиента (уход с сайта мерчанта), сложнее кастомизировать под бренд мерчанта.
        *   **Реализация:** Отдельное небольшое React/Vue/etc. приложение или набор серверных шаблонов, взаимодействующее с `backend/api_routers/gateway.py`.
    2.  **Платежный Виджет (Payment Widget):**
        *   **Описание:** JavaScript-код, который мерчант встраивает на свою страницу оформления заказа. Виджет отрисовывает необходимые элементы интерфейса (выбор метода, ввод данных, загрузка чека) внутри страницы мерчанта (например, в iframe или напрямую).
        *   **Плюсы:** Более бесшовный UX, потенциально больше возможностей кастомизации.
        *   **Минусы:** Более сложная интеграция для мерчанта, потенциальные проблемы с безопасностью (CORS, XSS), необходимость тщательного тестирования на сайтах мерчантов.
        *   **Реализация:** JavaScript-библиотека, которая взаимодействует с `backend/api_routers/gateway.py` и управляет своим UI.
*   **Рекомендация:** Начать с **Хостируемой Страницы Оплаты (HPP)** как более простого и контролируемого варианта. В дальнейшем можно разработать Виджет.
*   **Ключевые Компоненты UI (для HPP):**
    *   Форма инициации:
        *   Выбор метода оплаты, банка.
        *   Поле для ввода суммы: Отображается, **только если** сумма не была передана мерчантом в параметрах редиректа **И** настройка магазина `gateway_require_amount_param` равна `False`.
        *   Поле для ввода ID клиента магазина (`customer_id`): Отображается, **только если** `customer_id` не был передан мерчантом в параметрах **И** настройка магазина `gateway_require_customer_id_param` равна `False`.
    *   Отображение деталей подобранного реквизита.
    *   Поле для загрузки чека/скриншота.
    *   Кнопки подтверждения/отмены.
    *   Отображение статуса операции (ожидание, успех, ошибка).
    *   Автоматический редирект на `return_url` по завершению.

## 7. Стратегии Повторного Использования Кода (Multi-App)

Этот наиболее детализированный план предоставляет комплексное видение архитектуры фронтенда, учитывая как технические аспекты, так и процессы разработки и поддержки. 