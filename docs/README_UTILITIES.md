# Документация по утилитам backend

---

## 1. Общее Описание

Этот документ описывает набор утилит и вспомогательных модулей в директории `backend`, разработанных для реализации основной логики платежной системы JivaPay, описанной в `README_DB.md`. Эти утилиты обеспечивают надежное взаимодействие с базой данных, асинхронную обработку входящих заявок, подбор реквизитов, учет балансов, обработку ошибок и другие ключевые операции, направленные на создание **отказоустойчивой** и **надежной** системы.

Структура утилит ориентирована на поддержку асинхронной обработки заявок и транзакционной целостности данных.

---

## 2. Ключевые Утилиты и Модули

### 2.1. Утилиты для работы с Базой Данных (`database.utils` или аналогичный)

*   **Назначение:** Предоставление высокоуровневых, безопасных и отказоустойчивых функций для взаимодействия с моделями SQLAlchemy, управление сессиями и транзакциями.
*   **Основные функции:**
    *   `get_db_session` — FastAPI зависимость (`Depends`), предоставляющая сессию SQLAlchemy на время обработки запроса и автоматически закрывающая её после, определена в `backend/database/utils.py`.
    *   `get_db_session_cm` — контекстный менеджер в `backend/database/utils.py` для использования внутри сервисов и фоновых задач, гарантирующий корректное открытие/закрытие сессии и обработку транзакций.
    *   `atomic_transaction()`: Декоратор или менеджер контекста для выполнения блока кода в рамках атомарной транзакции. **Ключевая особенность:** автоматический ROLLBACK при любом исключении внутри блока и COMMIT при успешном завершении. Должен логировать начало, успех (COMMIT) и неудачу (ROLLBACK с причиной/исключением).
    *   CRUD-функции (например, `create_object`, `get_object_by_id`, `update_object`, `delete_object`): Обертки над стандартными операциями SQLAlchemy, включающие:
        *   Обработку специфичных исключений SQLAlchemy (например, `IntegrityError`, `NoResultFound`).
        *   Логирование операций и ошибок.
        *   Возможно, стандартизированные возвращаемые значения или кастомные исключения для единообразной обработки на верхних уровнях.

### 2.2. Логика подбора Реквизитов (`services.requisite_selector` или аналогичный)

*   **Назначение:** Инкапсуляция **критически важной** и сложной логики поиска и выбора подходящего реквизита трейдера. Должна быть **максимально надежной и транзакционно безопасной**.
    *   **Обновленное определение доступности трейдера/реквизита:** Логика должна учитывать следующие условия:
        *   Аккаунт пользователя трейдера активен: `Trader.user.is_active == True`.
        *   Трейдер самостоятельно включил прием трафика: `Trader.in_work == True`.
        *   Трафик для трейдера включен его тимлидом: `Trader.is_traffic_enabled_by_teamlead == True`.
        *   Статус самого реквизита трейдера активен: `ReqTrader.status == 'approve'` (или другой релевантный активный статус).
        *   Реквизит включен на соответствующее направление (pay-in/pay-out): `FullRequisitesSettings.pay_in == True` для PayIn или `FullRequisitesSettings.pay_out == True` для PayOut.
*   **Основные функции:**
    *   `find_suitable_requisite(incoming_order: IncomingOrder, db_session: Session)`: Основная функция, принимающая **объект входящей заявки** и **активную сессию БД**. Работает **внутри транзакции**, управляемой извне (например, из `order_processor`).
    *   **Внутренняя логика:**
        *   Загрузка связанных данных (настроек `FullRequisitesSettings`, данных трейдера) в рамках той же сессии.
        *   Выполнение **оптимизированного** SQL-запроса с JOIN, фильтрами и сортировкой. Использует `with_for_update(skip_locked=True)` для неблокирующего выбора кандидата при высокой конкуренции.
        *   **Round-robin:** Кандидаты сортируются по `Trader.trafic_priority` (ASC), затем по `ReqTrader.last_used_at` (ASC, NULLS FIRST), чтобы заявки равномерно распределялись между реквизитами с одинаковым приоритетом.
        *   После назначения заявки выбранному реквизиту обновляется поле `last_used_at` на текущее время.
        *   **Обработка сценариев:**
            *   **Кандидат не найден:** Возвращает специальный статус или `None`, логирует причину (нет подходящих по статическим параметрам).
            *   **Кандидат найден и заблокирован:**
                *   Проверка динамических лимитов: Выполняет агрегирующие запросы к `order_history` **в той же транзакции** для расчета текущего оборота.
                *   **Лимит превышен:** Освобождает блокировку (неявно при завершении транзакции без COMMIT), возвращает статус о превышении лимита, логирует детали.
                *   **Все проверки пройдены:** Возвращает ID найденного и **заблокированного** реквизита и трейдера.
        *   **Обработка ошибок:** Любые ошибки запросов к БД должны перехватываться, логироваться и приводить к откату транзакции на вызывающем уровне.

### 2.3. Обработка Входящих Заявок (`services.order_processor` или аналогичный)

*   **Назначение:** Оркестрация процесса обработки одной входящей заявки, координация подбора реквизита, создание ордера и обновление статусов с **гарантией атомарности** и **надежной фиксацией результата**.
*   **Основные функции:**
    *   `process_incoming_order(incoming_order_id: int)`: Главная функция, вызываемая Worker'ом.
    *   **Внутренняя логика:**
        1.  **Проверка идемпотентности:** Перед началом основной логики проверить, не была ли заявка с `incoming_order_id` уже успешно обработана (например, проверить наличие `OrderHistory` с `incoming_order_id` или статус `IncomingOrder`). Если да - просто выйти (или вернуть подтверждение).
        2.  Получение сессии БД (`get_db_session`).
        3.  **Начало основной атомарной транзакции** (`atomic_transaction`).
        4.  Загрузка `IncomingOrder` по ID **с блокировкой записи** (`with_for_update`) для предотвращения двойной обработки *параллельными* воркерами. Проверка текущего статуса (должен быть 'new' или 'retrying'). Если статус другой (уже 'assigned' или 'failed') - выход (транзакция откатится).
        5.  **Вызов Fraud Detection:** `fraud_detector.check_incoming_order(...)`. Обработка результата (`DENY` -> переход к шагу "Надежное обновление статуса"; `REQUIRE_MANUAL_REVIEW` -> аналогично, но с другим статусом).
        6.  Вызов `find_suitable_requisite`, передача объекта заявки и сессии.
        7.  **Анализ результата `find_suitable_requisite`:**
            *   **Успех (кандидат найден):**
                *   Расчет комиссии трейдера (с обработкой ошибок, если настройки не найдены).
                *   Создание новой записи в `order_history` (с фиксацией курса).
                *   Обновление `incoming_orders`: `status='assigned'`, `assigned_order_id`, `failure_reason=None`.
                *   **COMMIT основной транзакции** (выполняется менеджером `atomic_transaction`).
                *   Логирование успеха.
            *   **Неудача (кандидат не найден / лимит превышен / фрод):**
                *   Менеджер `atomic_transaction` выполнит **ROLLBACK** основной транзакции при выходе из блока без успеха.
                *   **Надежное обновление статуса IncomingOrder (вне основной транзакции):**
                    *   Получить **новую сессию БД**.
                    *   Начать **новую атомарную транзакцию**.
                    *   Загрузить `IncomingOrder` (уже без блокировки).
                    *   Определить, является ли ошибка временной (можно повторить) или постоянной.
                    *   Обновить `incoming_orders`: увеличение `retry_count`, `last_attempt_at`, запись `failure_reason`. Установка статуса `'retrying'` (если `retry_count` < max_retries) или `'failed'`.
                    *   **COMMIT** транзакции обновления статуса.
                    *   Логировать неуспех обновления статуса, если он произошел.
                *   Логирование неудачи основной обработки с причиной.
            *   **Исключение внутри основной транзакции:**
                *   Менеджер `atomic_transaction` выполнит **ROLLBACK** основной транзакции.
                *   **Надежное обновление статуса IncomingOrder (вне основной транзакции):** (Аналогично предыдущему пункту)
                    *   Получить **новую сессию БД**.
                    *   Начать **новую атомарную транзакцию**.
                    *   Загрузить `IncomingOrder`.
                    *   Обновить `incoming_orders`: увеличение `retry_count`, `last_attempt_at`, запись `failure_reason` (текст исключения), статус `'retrying'` или `'failed'`. 
                    *   **COMMIT** транзакции обновления статуса.
                    *   Логировать неуспех обновления статуса.
                *   Логирование критической ошибки основной обработки.
                *   Отправка оповещения (`report_critical_error`), если необходимо.

**Ключевое требование:** Обновление статуса `IncomingOrder` на `retrying` или `failed` должно происходить **надежно и изолированно** от основной транзакции обработки, чтобы гарантировать корректную работу механизма повторных попыток Worker'а и предотвратить бесконечную обработку сбойных заявок.

### 2.4. Фоновый Обработчик (Worker - `worker.order_processing` или аналогичный)

*   **Назначение:** **Отказоустойчивый** сервис для непрерывного выбора и запуска обработки заявок из очереди `incoming_orders`.
*   **Реализация:** Может быть реализован с использованием Celery, Dramatiq, asyncio или другого подходящего инструмента для фоновых задач.
*   **Логика:**
    *   **Выборка задач:** Периодически или по триггеру опрашивает `incoming_orders` на наличие записей со статусом `'new'` или `'retrying'` (где `last_attempt_at` + backoff_delay < now). Запрос должен быть **эффективным** (использовать индексы `ix_incoming_orders_status_created`).
    *   **Распределение:** Передает ID выбранных заявок в `process_incoming_order` (например, как задачи для Celery/Dramatiq worker'ов).
    *   **Обработка ошибок на уровне Worker'а:**
        *   Перехват **любых** исключений при выборке задач или запуске обработки.
        *   Логирование критических ошибок Worker'а.
        *   Реализация стратегии перезапуска Worker'а при сбоях.
        *   **Механизм Backoff:** При статусе `'retrying'` использовать экспоненциальную задержку (`last_attempt_at` + `retry_count` * backoff_factor) перед следующей попыткой.
        *   **Dead Letter Queue (DLQ):** Задачи, которые не удалось обработать после максимального числа попыток (статус `'failed'`), должны либо оставаться в БД для ручного анализа, либо перемещаться в отдельную "очередь мертвых писем" (если используется система очередей).
    *   **Мониторинг:** Worker должен предоставлять метрики (длина очереди, время обработки, количество ошибок) для систем мониторинга.

### 2.5. Утилиты для работы с Балансами и Комиссиями (`services.balance_manager` или аналогичный)

*   **Назначение:** **Надежное** обновление балансов и запись истории. Выполняется **после** успешного подтверждения выполнения ордера (статус `completed` в `order_history`), а не сразу после назначения реквизита.
*   **Основные функции:**
    *   `update_balances_for_completed_order(order_id: int)`:
        *   Работает в **атомарной транзакции**.
        *   Загружает `OrderHistory` и связанные `MerchantStore`, `Trader`.
        *   **Блокирует** строки балансов (`balance_stores`, `balance_traders`) для обновления (`FOR UPDATE`).
        *   Обновляет `balance` в `balance_stores` и `balance_traders`.
        *   Обновляет `balance` в `balance_platform`.
        *   Создает записи в `balance_store_history`, `balance_trader_fiat_history`, `balance_trader_crypto_history` и `balance_platform_history` для фиксации прибыли платформы (использует поле `platform_profit` из `OrderHistory`).
        *   Обрабатывает возможные ошибки (например, недостаточный баланс, если это применимо), логирует и откатывает транзакцию.
    *   `calculate_commissions(order_details)`: Рассчитывает комиссии. Должна обрабатывать случаи отсутствия настроек комиссий (использовать значения по умолчанию или вызывать ошибку).

### 2.6. Утилиты для работы со Справочниками (`services.reference_data` или аналогичный)

*   **Назначение:** Предоставление доступа к справочным данным с **кэшированием** и обработкой ошибок.
*   **Основные функции:**
    *   Функции `get_...`: `get_exchange_rate`, `get_fiat_currency_details`, `get_payment_method_details` и т.д.
    *   **Курсы Валют (`get_exchange_rate`):**
        *   **Источник:** Необходимо определить источник курсов (например, API внешнего провайдера типа Binance, CoinMarketCap, или внутренний механизм установки курсов администратором).
        *   **Обновление:** Данные должны регулярно обновляться (например, фоновой задачей Worker'а каждые N минут).
        *   **Кэширование:** Активно использовать кэширование (Redis/Memcached) для снижения нагрузки на источник и БД.
        *   **Обработка ошибок источника/обновления:** При невозможности обновить курс, использовать последнее актуальное значение из кэша/БД. Если актуального значения нет (старое или отсутствует), необходимо вернуть ошибку (`ConfigurationError` или аналогичную), чтобы предотвратить операции по некорректному курсу. Логировать такие ситуации и отправлять оповещения.
    *   **Кэширование (Общее):** Реализовать кэширование и для других часто запрашиваемых справочных данных (банки, методы оплаты) для снижения нагрузки на БД (использовать Redis, Memcached или кэш в памяти с TTL).
    *   **Обработка ошибок (Общее):** Если данные не найдены в справочнике (например, неверный ID), возвращать `None` или выбрасывать специфическое исключение. Логировать такие случаи.

### 2.7. Утилиты Обработки Ошибок и Оповещений (`utils.exceptions`, `utils.exception_handlers`, `utils.notifications`)

*   **Назначение:** Централизованная обработка, классификация ошибок, и отправка оповещений.
*   **Компоненты:**
    *   **Кастомные классы исключений (`utils.exceptions`):** Определена иерархия кастомных исключений, наследуемых от базового `JivaPayException` (например, `RequisiteNotFound`, `LimitExceeded`, `ConfigurationError`). Эти исключения используются во всей бизнес-логике для сигнализации о специфических ошибках.
    *   **Глобальный обработчик исключений FastAPI (`utils.exception_handlers`):** В FastAPI приложениях зарегистрирован глобальный обработчик для `JivaPayException` и его производных. Этот обработчик отвечает за формирование стандартизированного JSON-ответа с соответствующим HTTP-статусом, если исключение не было обработано на более низком уровне (например, в сервисе для выполнения специфических действий, таких как обновление статуса заказа перед тем, как ошибка выйдет за пределы сервиса). Это упрощает код в API-роутерах, избавляя от необходимости дублировать `try-except` блоки для известных бизнес-исключений.
    *   **Централизованный логгер ошибок:** Конфигурируется в `config.logger` для журналирования деталей ошибок.
    *   **Интеграция с системой мониторинга/оповещений (`utils.notifications`):** Отправка критических ошибок (например, сбои Worker'а, ошибки транзакций, большое кол-во заявок в статусе 'failed') в Sentry, Prometheus/Alertmanager, PagerDuty и т.д.
    *   `report_critical_error(exception, context)`: Функция в `utils.notifications` для отправки отчета об ошибке во внешние системы.

### 2.8. Сервис Статистики и Управления Пользователями (`services.user_service` - расширение)

*   **Назначение (расширенное):** Помимо существующей логики работы с пользователями и ролями, сервис предоставляет функции для:
    *   Сбора и агрегации статистики по администраторам, тимлидам и саппортам с различными фильтрами. **Эти функции (`get_administrators_statistics`, `get_supports_statistics`, `get_teamleads_statistics`) были рефакторены для использования общих утилит из `backend/utils/query_utils.py` для применения фильтров (например, по статусу пользователя), сортировки и пагинации. Они принимают стандартизированные параметры `page`, `per_page`, `sort_by`, `sort_direction` и возвращают словарь, содержащий `total_count`, `page`, `per_page` и список `data`.**
    *   Получения детальной информации о профилях пользователей (`Admin`, `Support`, `TeamLead`), включая их гранулярные права (`granted_permissions`).
    *   Обновления данных профилей (`Admin`, `Support`, `TeamLead`) и статуса пользователя (`User.is_active`), с проверкой прав текущего администратора через `services.permission_service`. **Функции обновления профилей были рефакторены для использования общей вспомогательной функции `_update_user_and_profile_generic`, что унифицировало логику обновления, проверок прав и аудита.**
*   **Ключевые функции (дополнительно):**
    *   `get_administrators_statistics(...)`, `get_teamleads_statistics(...)`, `get_supports_statistics(...)`
    *   `get_administrator_details(...)`, `update_administrator_profile(...)`
    *   `get_support_details(...)`, `update_support_profile(...)`
    *   `get_teamlead_details(...)`, `update_teamlead_profile(...)`

### 2.9. Сервис Ордеров (`services.order_service` - новый или значительное расширение)

*   **Назначение:** Предоставление расширенных возможностей для работы с историей ордеров, в основном для административных нужд и поддержки, с учетом гранулярных прав.
*   **Ключевые функции:**
    *   `get_orders_history(db_session: Session, ..., current_user: User)`: Комплексный сервис для выборки ордеров с фильтрацией (включая `amount_exact`, `amount_min`, `amount_max`, диапазоны дат, поиск по различным полям), сортировкой и пагинацией. **Эта функция была рефакторена для использования `backend/utils/query_utils.py` (например, `apply_date_range_filter`, `apply_sorting`, `get_paginated_results_and_count`). Принимает стандартизированные параметры `page`, `per_page`, `sort_by`, `sort_direction` и возвращает словарь, содержащий `total_count`, `page`, `per_page` и список `data` (ордера).** Использует `PermissionService` для проверки прав `current_user` и соответствующей фильтрации данных.
    *   `get_orders_count(db_session: Session, ..., current_user: User)`: Подсчет количества ордеров с фильтрами (по статусу, диапазону дат), с учетом прав доступа. **Эта функция также была рефакторена для более последовательного применения фильтров и возвращает словарь `{"total_count": count}`.**

### 2.10. Сервис Реквизитов (`services.requisite_service` - новый или расширение)

*   **Назначение:** Управление и предоставление статистики по реквизитам, с учетом гранулярных прав.
*   **Ключевые функции:**
    *   `get_online_requisites_stats(db_session: Session, ..., current_user: User)`: Возвращает количество и список активных ("онлайн") реквизитов с возможностью фильтрации (по типу реквизита, трейдеру, платежному методу, банку, тимлиду) и сортировки. Логика "онлайн" статуса реквизита соответствует описанию в п. 2.2. **Эта функция была рефакторена для использования `backend/utils/query_utils.py` (например, `apply_sorting`, `get_paginated_results_and_count`). Принимает стандартизированные параметры `page`, `per_page`, `sort_by`, `sort_direction` и возвращает словарь, содержащий `total_online` (общее количество), `page`, `per_page` и список `data` (реквизиты).** Проверяет права `current_user` через `PermissionService` и применяет соответствующие фильтры (например, для тимлидов или саппортов с ограниченными правами).
    *   `get_requisite_details_for_moderation(db_session: Session, requisite_id: int, current_admin_user: User)`: Предоставляет детали реквизита для модерации администратором.
    *   `set_requisite_status(db_session: Session, requisite_id: int, status: str, current_admin_user: User, ip_address: Optional[str])`: Устанавливает статус реквизита с проверкой прав администратора и записью в аудит-лог.

### 2.11. Сервис Платформы (`services.platform_service` - новый)

*   **Назначение:** Предоставление информации о состоянии платформы.
*   **Ключевые функции:**
    *   `get_platform_balances(db_session: Session)`: Агрегирует и возвращает текущие балансы платформы по различным валютам из `BalancePlatform`.

### 2.12. Сервис Трейдеров (`services.trader_service` - новый или расширение)

*   **Назначение:** Предоставление статистики и детальной информации по трейдерам для администраторов и (в ограниченном виде, согласно правам) для саппортов.
*   **Ключевые функции:**
    *   `get_traders_statistics(db_session: Session, ..., current_user: User)`: Комплексная статистика по трейдерам с фильтрацией (по статусу пользователя, онлайн-статусу трейдера, периоду оборота, ID валюты, ID платежного метода, поисковому запросу) и сортировкой. **Эта функция была рефакторена для использования `backend/utils/query_utils.py` (например, `apply_user_status_filter`, `apply_sorting`, `get_paginated_results_and_count`). Принимает стандартизированные параметры `page`, `per_page`, `sort_by`, `sort_direction` и возвращает словарь, содержащий `total_count`, `page`, `per_page`, список `data` (трейдеры со статистикой) и `statistics_columns` (метаданные для отображения колонок статистики).** Учитывает права `current_user` через `PermissionService`, включая гранулярные права для саппортов (например, ограничение по разрешенным платежным методам).
    *   `get_trader_full_details(db_session: Session, trader_id: int, current_admin_user: User)`: Возвращает всю связанную информацию о трейдере. Проверяет права администратора (`current_admin_user`) через `PermissionService`.

### 2.13. Сервис Мерчантов (`services.merchant_service` - новый или расширение)

*   **Назначение:** Аналогично `trader_service`, но для мерчантов и их магазинов.
*   **Ключевые функции:**
    *   `get_merchants_statistics(db_session: Session, ..., current_user: User)`: Комплексная статистика по мерчантам с фильтрацией (по статусу пользователя, периоду оборота, поисковому запросу, включая поиск по названию магазина) и сортировкой. **Эта функция была рефакторена для использования `backend/utils/query_utils.py` (например, `apply_user_status_filter`, `apply_sorting`, `get_paginated_results_and_count`). Принимает стандартизированные параметры `page`, `per_page`, `sort_by`, `sort_direction` и возвращает словарь, содержащий `total_count`, `page`, `per_page`, список `data` (мерчанты со статистикой) и `statistics_columns`.** Проверяет права `current_user` через `PermissionService`.
    *   `get_merchant_full_details(db_session: Session, merchant_id: int, current_user: User)`: Возвращает всю связанную информацию о мерчанте. Проверяет права `current_user` через `PermissionService`.

### 2.14. Сервис Управления Правами (`services.permission_service` - новый)

*   **Назначение:** Централизованное управление и проверка гранулярных прав доступа (списков строк из JSON-полей `granted_permissions` в моделях `Admin`, `Support`, `TeamLead`).
*   **Ключевые функции:**
    *   `get_user_permissions(db_session: Session, user_id: int, user_role: str) -> List[str]`: Получает список прав для пользователя указанной роли из его профиля.
    *   `update_user_permissions(db_session: Session, target_user_id: int, target_user_role: str, permissions_to_set: List[str], current_admin_user: User, ip_address: Optional[str])`: Обновляет список прав для пользователя. Требует проверки прав у `current_admin_user` (например, `admin:manage:permissions:<target_user_role>`). Выполняет аудит-логирование через `audit_logger.log_event`.
    *   `check_permission(user_id: Optional[int], user_role: Optional[str], required_permission_template: str, target_entity_id: Optional[Union[int, str]] = None) -> bool`: Проверяет, есть ли у пользователя необходимое право. Загружает права пользователя через `get_user_permissions` и использует `_match_permission`.
    *   `_match_permission(user_permissions: List[str], required_permission_template: str, target_entity_id: Optional[Union[int, str]], user_role_for_log: str, user_id_for_log: Optional[int]) -> bool`: Внутренний метод для сопоставления права с учетом wildcards (`*`) и плейсхолдера `{id}`.
    *   Примеры строковых разрешений: `["orders:view:all_details", "users:edit:trader:{id}", "platform:view:balance", "requisites:view:online_stats_all"]`.

### 2.15. Сервис Тимлидов (`services.teamlead_service` - новый или расширение)

*   **Назначение:** Предоставление функционала для роли Тимлида, включая управление командой, просмотр статистики и взаимодействие с трейдерами команды.
*   **Ключевые функции:**
    *   `get_managed_traders(db_session: Session, current_teamlead_user: User)`: Получение списка трейдеров, управляемых текущим тимлидом.
    *   `set_trader_traffic_status_by_teamlead(db_session: Session, trader_id_to_manage: int, enable_traffic: bool, current_teamlead_user: User, ip_address: Optional[str])`: Установка флага `Trader.is_traffic_enabled_by_teamlead` для трейдера в команде, с проверкой прав и аудит-логированием.
    *   `get_team_statistics(db_session: Session, current_teamlead_user: User)`: Получение агрегированной статистики по команде тимлида.
    *   `get_teamlead_full_details(db_session: Session, teamlead_id_to_view: int, current_user: User)`: Получение полной информации о тимлиде (для администраторов).
    *   Логика расчета активных реквизитов (`active_reqs`) в методах статистики учитывает все три флага активности трейдера.

### 2.16. Сервис Аудита (`services.audit_service` - новый или расширение `audit_logger.py`)

*   **Назначение (расширенное):** Помимо записи событий, предоставляет функции для их извлечения, особенно для критических системных ошибок.
*   **Ключевые функции (дополнительно):**
    *   `get_critical_system_errors(db_session: Session, page: int, per_page: int, filters: Optional[dict])`: Извлекает логи из `AuditLog` с типом `system_error` и уровнем `critical`, с возможностью фильтрации.
    *   Для получения `user_id`, `user_role`, `ip_address` можно использовать зависимости FastAPI (`Depends(get_current_user)`, `Request`).

**Цель:** Предоставить возможность расследования инцидентов, мониторинга активности пользователей и подтверждения выполнения операций.

### 2.18. Утилиты для построения запросов (`utils.query_utils` - новый)

*   **Назначение:** Предоставление набора вспомогательных функций для стандартизации и упрощения построения и выполнения SQLAlchemy запросов, особенно для списков с фильтрацией, сортировкой и пагинацией.
*   **Основные функции:**
    *   `apply_pagination(query: Query, page: int, per_page: int) -> Query`:
        *   Применяет `offset` и `limit` к запросу для пагинации.
        *   Включает базовую валидацию для `page` (>=1) и `per_page` (>=1, с значением по умолчанию).
    *   `apply_sorting(query: Query, sort_by: Optional[str], sort_direction: Optional[str], sort_field_map: Dict[str, Any], default_sort_column: Optional[Any]) -> Query`:
        *   Применяет `order_by` к запросу.
        *   `sort_field_map`: Словарь, отображающий строковые ключи (параметры API) на атрибуты модели SQLAlchemy (например, `{"name": User.name}`) или строковые имена вычисляемых полей.
        *   `default_sort_column`: Атрибут модели или ключ из `sort_field_map` для сортировки по умолчанию.
    *   `apply_user_status_filter(query: Query, user_model_alias: Type[Any], status_filter: Optional[str]) -> Query`:
        *   Фильтрует запрос по полю `is_active` указанного псевдонима модели пользователя (`user_model_alias`).
        *   Поддерживает значения `status_filter`: 'active', 'inactive'.
    *   `apply_date_range_filter(query: Query, date_column: Any, start_time: Optional[datetime], end_time: Optional[datetime]) -> Query`:
        *   Применяет фильтр по диапазону дат к указанному столбцу `date_column`.
    *   `get_paginated_results_and_count(base_query: Query, count_query: Query, page: int, per_page: int) -> Tuple[List[Any], int]`:
        *   Выполняет два запроса: `count_query` для получения общего количества записей и `base_query` (с примененной пагинацией) для получения списка записей на текущей странице.
        *   Возвращает кортеж: `(list_of_results, total_count)`.
        *   Обрабатывает потенциальные ошибки при выполнении запросов, выбрасывая `DatabaseError`.
*   **Интеграция:** Эти утилиты используются в сервисных функциях (например, в `user_service.py` для `get_..._statistics`) для уменьшения дублирования кода и стандартизации обработки запросов.

---

## Дополнительные и расширенные сервисы (Admin, Support, TeamLead)

Раздел ниже описывает новые или значительно доработанные сервисы, необходимые для реализации расширенного функционала администрирования, поддержки и управления командами, как указано в `docs/ADDITIONAL_FEATURES_AND_COMPONENTS.md`.

### 2.17. Сервис Аудита (`services.audit_logger`)

**Назначение:** Обеспечение отслеживаемости и подотчетности действий пользователей и системы путем записи ключевых событий в специальный лог.

**Компоненты и Функционал:**

1.  **Модель `AuditLog` (в `db.py`):** Определяет структуру записи аудита (см. `README_DB.md`).
2.  **Сервис `AuditLogger`:**
    *   **Описание:** Предоставляет простой интерфейс для записи событий аудита из различных частей системы.
    *   **Основная функция:** `log_action(action: str, user_id: Optional[int], user_role: Optional[str], target_entity: Optional[str] = None, target_id: Optional[int] = None, details: Optional[dict] = None, ip_address: Optional[str] = None, db_session: Session)`.
    *   **Реализация:**
        *   Принимает необходимые параметры.
        *   Создает объект `AuditLog`.
        *   Добавляет его в **текущую сессию БД** `db_session`. Запись аудита должна быть частью той же транзакции, что и основное действие, чтобы гарантировать, что аудит записывается только при успешном выполнении действия.
        *   Не должна прерывать основное выполнение при ошибке записи аудита (но должна логировать саму ошибку записи аудита).
3.  **Интеграция:**
    *   Функция `log_action` должна вызываться из всех критически важных мест системы:
        *   После успешного логина/выхода.
        *   При изменении статусов/данных магазинов, реквизитов, пользователей.
        *   При подтверждении/отмене ордеров.
        *   При ручных операциях администраторов.
        *   При важных системных событиях (например, сбой обработки ордера).
    *   Для получения `user_id`, `user_role`, `ip_address` можно использовать зависимости FastAPI (`Depends(get_current_user)`, `Request`).

**Цель:** Предоставить возможность расследования инцидентов, мониторинга активности пользователей и подтверждения выполнения операций.

---

## 3. Механизм Подтверждения Статуса Ордера

**Назначение:** Обеспечение корректного завершения жизненного цикла ордера (`order_history`) после его назначения трейдеру, включая обработку подтверждений от трейдера и клиента (для PayIn), расчет комиссий и обновление балансов. Этот механизм является критически важным для консистентности финансовых данных.

**Компоненты и Функционал:**

1.  **API Эндпоинты для Статусов Ордера (в соответствующих `api_routers`):**
    *   **Для Трейдера (`/api/trader/orders/{order_id}/confirm`, `/api/trader/orders/{order_id}/cancel` и т.д.):**
        *   Позволяет трейдеру подтвердить успешное выполнение (прикрепив чек для PayOut) или отменить/оспорить ордер.
        *   Должны проверять, что ордер назначен именно этому трейдеру и находится в соответствующем статусе (например, 'assigned').
        *   Требуют загрузки подтверждающих документов (чек для PayOut).
    *   **Для Клиента PayIn (через API мерчанта):**
        *   Эндпоинт для клиента (вызываемый через фронтенд мерчанта или API мерчанта) для подтверждения совершения оплаты и загрузки чека/скриншота.
        *   Изменяет статус `OrderHistory` на 'pending_trader_confirmation' (или аналогичный), делая ордер видимым для подтверждения трейдером.
    *   **Для Администратора/Саппорта:** Эндпоинты для ручного изменения статуса ордера в спорных ситуациях.

2.  **Сервис Управления Статусами Ордера (`services.order_status_manager`):**
    *   **Описание:** Инкапсулирует логику перехода `OrderHistory` между статусами (`assigned` -> `pending_trader_confirmation` (PayIn) -> `completed` / `failed` / `cancelled` / `dispute`).
    *   **Основные функции:**
        *   `confirm_payment_by_client(order_id: int, proof_document_url: str, db_session: Session)`: Вызывается из API мерчанта. Обновляет статус на 'pending_trader_confirmation', сохраняет ссылку на документ.
        *   `confirm_order_by_trader(order_id: int, trader_id: int, proof_document_url: Optional[str], db_session: Session)`: Вызывается из API трейдера.
            *   Проверяет права трейдера и текущий статус ордера.
            *   Обновляет статус на `completed`.
            *   **Важно:** *После* успешного COMMIT этой транзакции, инициирует вызов `services.balance_manager.update_balances_for_completed_order(order_id)` (например, через фоновую задачу или прямой вызов, если он быстрый и надежный).
        *   `cancel_order(order_id: int, user_id: int, role: str, reason: str, db_session: Session)`: Обрабатывает отмену ордера, возможно, с возвратом замороженных средств (требует доп. логики в `balance_manager`).
        *   `dispute_order(...)`: Обработка спорных ситуаций.
    *   **Транзакционность:** Все операции по изменению статуса должны выполняться в рамках атомарных транзакций (`database.utils.atomic_transaction`).
    *   **Заморозка/Разморозка Балансов:**
        *   **При назначении ордера (`order_processor`):** Происходит *неявная* заморозка за счет проверки лимитов. Для PayOut может потребоваться *явная* проверка и возможно блокировка части крипто-баланса трейдера (сложнее реализовать). **Уточнение:** Ваше описание указывает, что заморозка/списание происходит *после* подтверждения. Это упрощает логику при назначении. Расчеты и списания/начисления происходят только при переходе в `completed`.
        *   **При отмене/провале:** Если была явная заморозка, требуется логика разморозки.

3.  **Фоновый процесс для Таймаутов (Опционально):**
    *   **Описание:** Worker может отслеживать ордера, "зависшие" в промежуточных статусах дольше установленного времени (`processing_ttl` из `MerchantStore` или глобальный).
    *   **Действие:** Может автоматически переводить ордер в статус 'failed' или 'requires_attention' и отправлять уведомление.

**Взаимодействие:**

*   API роутеры вызывают функции `services.order_status_manager`.
*   `order_status_manager` использует `database.utils` для работы с БД и `balance_manager` (опосредованно, после подтверждения) для обновления балансов.
*   Worker может взаимодействовать с `order_status_manager` для обработки таймаутов.

**Математика и Курсы:**

*   Момент фиксации курса для расчета сумм и комиссий критичен. Вероятно, он должен фиксироваться при создании `OrderHistory` в `order_processor` и сохраняться в `OrderHistory`.
*   Все расчеты комиссий и обновления балансов в `balance_manager` должны использовать **зафиксированный курс** из `OrderHistory`.

---

## 4. Сервис Обнаружения Мошенничества (`services.fraud_detector`)

**Назначение:** Снижение рисков мошеннических операций путем анализа транзакций и активности пользователей на основе предопределенных правил и паттернов.

**Компоненты и Функционал:**

1.  **Хранилище Правил и Порогов:**
    *   Конфигурация порогов (например, макс. сумма/количество транзакций в час/день для пользователя/IP/реквизита/client_id).
    *   Возможность ведения списков (черные/белые списки IP, реквизитов, пользователей).
    *   Может храниться в конфигурации, отдельной таблице БД или Redis.

2.  **Сервис `FraudDetectionService`:**
    *   **Основные функции:**
        *   `check_incoming_order(order: IncomingOrder, db_session: Session) -> FraudCheckResult`:
            *   Вызывается из `order_processor` *перед* подбором реквизита.
            *   Проверяет ордер по velocity-лимитам (требует запросов к `order_history` или агрегирующим таблицам/счетчикам).
            *   Проверяет наличие участников (IP, client_id, возможно, реквизиты) в черных/белых списках.
            *   Возвращает результат: `ALLOW`, `DENY`, `REQUIRE_MANUAL_REVIEW`.
        *   `check_order_confirmation(...) -> FraudCheckResult`:
            *   Может вызываться из `order_status_manager` при подтверждении.
            *   Проверяет на подозрительные паттерны подтверждения.
    *   **Хранение Счетчиков (Velocity):** Для эффективного подсчета частоты операций рекомендуется использовать Redis (с TTL) или специализированные таблицы/материализованные представления в БД.

3.  **Интеграция:**
    *   `order_processor` должен вызывать `check_incoming_order`. При результате `DENY` - ордер сразу переводится в `failed`. При `REQUIRE_MANUAL_REVIEW` - в специальный статус, требующий вмешательства админа/саппорта.
    *   Результаты проверок должны логироваться в `AuditLog`.
    *   Система оповещений (`